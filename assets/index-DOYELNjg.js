var C=Object.defineProperty;var L=(t,e,n)=>e in t?C(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var g=(t,e,n)=>L(t,typeof e!="symbol"?e+"":e,n);import{K as c,r as l,L as N,n as m,k as P,M,N as k,g as R,d as B,O as K,P as Q,Q as U}from"./lifecycle-GEIIOlY5.js";const d=[],I=[];let u=[];const y=[],z=Promise.resolve();let x=!1;function A(){x||(x=!0,z.then(V))}function w(t){u.push(t)}function Z(t){y.push(t)}const p=new Set;let f=0;function V(){if(f!==0)return;const t=N;do{try{for(;f<d.length;){const e=d[f];f++,c(e),D(e.$$)}}catch(e){throw d.length=0,f=0,e}for(c(null),d.length=0,f=0;I.length;)I.pop()();for(let e=0;e<u.length;e+=1){const n=u[e];p.has(n)||(p.add(n),n())}u.length=0}while(d.length);for(;y.length;)y.pop()();x=!1,p.clear(),c(t)}function D(t){if(t.fragment!==null){t.update(),l(t.before_update);const e=t.dirty;t.dirty=[-1],t.fragment&&t.fragment.p(t.ctx,e),t.after_update.forEach(w)}}function F(t){const e=[],n=[];u.forEach(s=>t.indexOf(s)===-1?e.push(s):n.push(s)),n.forEach(s=>s()),u=e}const $=new Set;let o;function q(){o={r:0,c:[],p:o}}function tt(){o.r||l(o.c),o=o.p}function G(t,e){t&&t.i&&($.delete(t),t.i(e))}function et(t,e,n,s){if(t&&t.o){if($.has(t))return;$.add(t),o.c.push(()=>{$.delete(t),s&&(n&&t.d(1),s())}),t.o(e)}else s&&s()}function nt(t,e,n){const s=t.$$.props[e];s!==void 0&&(t.$$.bound[s]=n,n(t.$$.ctx[s]))}function st(t){t&&t.c()}function at(t,e){t&&t.l(e)}function H(t,e,n){const{fragment:s,after_update:i}=t.$$;s&&s.m(e,n),w(()=>{const _=t.$$.on_mount.map(K).filter(P);t.$$.on_destroy?t.$$.on_destroy.push(..._):l(_),t.$$.on_mount=[]}),i.forEach(w)}function J(t,e){const n=t.$$;n.fragment!==null&&(F(n.after_update),l(n.on_destroy),n.fragment&&n.fragment.d(e),n.on_destroy=n.fragment=null,n.ctx=[])}function T(t,e){t.$$.dirty[0]===-1&&(d.push(t),A(),t.$$.dirty.fill(0)),t.$$.dirty[e/31|0]|=1<<e%31}function rt(t,e,n,s,i,_,b=null,j=[-1]){const h=N;c(t);const a=t.$$={fragment:null,ctx:[],props:_,update:m,not_equal:i,bound:k(),on_mount:[],on_destroy:[],on_disconnect:[],before_update:[],after_update:[],context:new Map(e.context||(h?h.$$.context:[])),callbacks:k(),dirty:j,skip_bound:!1,root:e.target||h.$$.root};b&&b(a.root);let v=!1;if(a.ctx=n?n(t,e.props||{},(r,E,...S)=>{const O=S.length?S[0]:E;return a.ctx&&i(a.ctx[r],a.ctx[r]=O)&&(!a.skip_bound&&a.bound[r]&&a.bound[r](O),v&&T(t,r)),E}):[],a.update(),v=!0,l(a.before_update),a.fragment=s?s(a.ctx):!1,e.target){if(e.hydrate){Q();const r=R(e.target);a.fragment&&a.fragment.l(r),r.forEach(B)}else a.fragment&&a.fragment.c();e.intro&&G(t.$$.fragment),H(t,e.target,e.anchor),U(),V()}c(h)}class it{constructor(){g(this,"$$");g(this,"$$set")}$destroy(){J(this,1),this.$destroy=m}$on(e,n){if(!P(n))return m;const s=this.$$.callbacks[e]||(this.$$.callbacks[e]=[]);return s.push(n),()=>{const i=s.indexOf(n);i!==-1&&s.splice(i,1)}}$set(e){this.$$set&&!M(e)&&(this.$$.skip_bound=!0,this.$$set(e),this.$$.skip_bound=!1)}}const ot="4.2.19",W="4";typeof window<"u"&&(window.__svelte||(window.__svelte={v:new Set})).v.add(W);export{it as S,ot as V,et as a,at as b,tt as c,J as d,st as e,I as f,q as g,nt as h,rt as i,Z as j,w as k,H as m,G as t};
//# sourceMappingURL=index-DOYELNjg.js.map

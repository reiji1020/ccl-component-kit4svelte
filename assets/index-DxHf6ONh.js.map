{"version":3,"file":"index-DxHf6ONh.js","sources":["../../../node_modules/.pnpm/jsdoc-type-pratt-parser@4.1.0/node_modules/jsdoc-type-pratt-parser/dist/index.js","../../../node_modules/.pnpm/@storybook+core@8.5.8_prettier@3.3.3/node_modules/@storybook/core/dist/docs-tools/index.js"],"sourcesContent":["(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n    typeof define === 'function' && define.amd ? define(['exports'], factory) :\n    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.jtpp = {}));\n})(this, (function (exports) { 'use strict';\n\n    function tokenToString(token) {\n        if (token.text !== undefined && token.text !== '') {\n            return `'${token.type}' with value '${token.text}'`;\n        }\n        else {\n            return `'${token.type}'`;\n        }\n    }\n    class NoParsletFoundError extends Error {\n        constructor(token) {\n            super(`No parslet found for token: ${tokenToString(token)}`);\n            this.token = token;\n            Object.setPrototypeOf(this, NoParsletFoundError.prototype);\n        }\n        getToken() {\n            return this.token;\n        }\n    }\n    class EarlyEndOfParseError extends Error {\n        constructor(token) {\n            super(`The parsing ended early. The next token was: ${tokenToString(token)}`);\n            this.token = token;\n            Object.setPrototypeOf(this, EarlyEndOfParseError.prototype);\n        }\n        getToken() {\n            return this.token;\n        }\n    }\n    class UnexpectedTypeError extends Error {\n        constructor(result, message) {\n            let error = `Unexpected type: '${result.type}'.`;\n            if (message !== undefined) {\n                error += ` Message: ${message}`;\n            }\n            super(error);\n            Object.setPrototypeOf(this, UnexpectedTypeError.prototype);\n        }\n    }\n    // export class UnexpectedTokenError extends Error {\n    //   private expected: Token\n    //   private found: Token\n    //\n    //   constructor (expected: Token, found: Token) {\n    //     super(`The parsing ended early. The next token was: ${tokenToString(token)}`)\n    //\n    //     this.token = token\n    //\n    //     Object.setPrototypeOf(this, EarlyEndOfParseError.prototype)\n    //   }\n    //\n    //   getToken() {\n    //     return this.token\n    //   }\n    // }\n\n    function makePunctuationRule(type) {\n        return text => {\n            if (text.startsWith(type)) {\n                return { type, text: type };\n            }\n            else {\n                return null;\n            }\n        };\n    }\n    function getQuoted(text) {\n        let position = 0;\n        let char;\n        const mark = text[0];\n        let escaped = false;\n        if (mark !== '\\'' && mark !== '\"') {\n            return null;\n        }\n        while (position < text.length) {\n            position++;\n            char = text[position];\n            if (!escaped && char === mark) {\n                position++;\n                break;\n            }\n            escaped = !escaped && char === '\\\\';\n        }\n        if (char !== mark) {\n            throw new Error('Unterminated String');\n        }\n        return text.slice(0, position);\n    }\n    const identifierStartRegex = /[$_\\p{ID_Start}]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n    // A hyphen is not technically allowed, but to keep it liberal for now,\n    //  adding it here\n    const identifierContinueRegex = /[$\\-\\p{ID_Continue}\\u200C\\u200D]|\\\\u\\p{Hex_Digit}{4}|\\\\u\\{0*(?:\\p{Hex_Digit}{1,5}|10\\p{Hex_Digit}{4})\\}/u;\n    function getIdentifier(text) {\n        let char = text[0];\n        if (!identifierStartRegex.test(char)) {\n            return null;\n        }\n        let position = 1;\n        do {\n            char = text[position];\n            if (!identifierContinueRegex.test(char)) {\n                break;\n            }\n            position++;\n        } while (position < text.length);\n        return text.slice(0, position);\n    }\n    // we are a bit more liberal than TypeScript here and allow `NaN`, `Infinity` and `-Infinity`\n    const numberRegex = /^(NaN|-?((\\d*\\.\\d+|\\d+)([Ee][+-]?\\d+)?|Infinity))/;\n    function getNumber(text) {\n        var _a, _b;\n        return (_b = (_a = numberRegex.exec(text)) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;\n    }\n    const identifierRule = text => {\n        const value = getIdentifier(text);\n        if (value == null) {\n            return null;\n        }\n        return {\n            type: 'Identifier',\n            text: value\n        };\n    };\n    function makeKeyWordRule(type) {\n        return text => {\n            if (!text.startsWith(type)) {\n                return null;\n            }\n            const prepends = text[type.length];\n            if (prepends !== undefined && identifierContinueRegex.test(prepends)) {\n                return null;\n            }\n            return {\n                type,\n                text: type\n            };\n        };\n    }\n    const stringValueRule = text => {\n        const value = getQuoted(text);\n        if (value == null) {\n            return null;\n        }\n        return {\n            type: 'StringValue',\n            text: value\n        };\n    };\n    const eofRule = text => {\n        if (text.length > 0) {\n            return null;\n        }\n        return {\n            type: 'EOF',\n            text: ''\n        };\n    };\n    const numberRule = text => {\n        const value = getNumber(text);\n        if (value === null) {\n            return null;\n        }\n        return {\n            type: 'Number',\n            text: value\n        };\n    };\n    const rules = [\n        eofRule,\n        makePunctuationRule('=>'),\n        makePunctuationRule('('),\n        makePunctuationRule(')'),\n        makePunctuationRule('{'),\n        makePunctuationRule('}'),\n        makePunctuationRule('['),\n        makePunctuationRule(']'),\n        makePunctuationRule('|'),\n        makePunctuationRule('&'),\n        makePunctuationRule('<'),\n        makePunctuationRule('>'),\n        makePunctuationRule(','),\n        makePunctuationRule(';'),\n        makePunctuationRule('*'),\n        makePunctuationRule('?'),\n        makePunctuationRule('!'),\n        makePunctuationRule('='),\n        makePunctuationRule(':'),\n        makePunctuationRule('...'),\n        makePunctuationRule('.'),\n        makePunctuationRule('#'),\n        makePunctuationRule('~'),\n        makePunctuationRule('/'),\n        makePunctuationRule('@'),\n        makeKeyWordRule('undefined'),\n        makeKeyWordRule('null'),\n        makeKeyWordRule('function'),\n        makeKeyWordRule('this'),\n        makeKeyWordRule('new'),\n        makeKeyWordRule('module'),\n        makeKeyWordRule('event'),\n        makeKeyWordRule('external'),\n        makeKeyWordRule('typeof'),\n        makeKeyWordRule('keyof'),\n        makeKeyWordRule('readonly'),\n        makeKeyWordRule('import'),\n        makeKeyWordRule('is'),\n        makeKeyWordRule('in'),\n        makeKeyWordRule('asserts'),\n        numberRule,\n        identifierRule,\n        stringValueRule\n    ];\n    const breakingWhitespaceRegex = /^\\s*\\n\\s*/;\n    class Lexer {\n        static create(text) {\n            const current = this.read(text);\n            text = current.text;\n            const next = this.read(text);\n            text = next.text;\n            return new Lexer(text, undefined, current.token, next.token);\n        }\n        constructor(text, previous, current, next) {\n            this.text = '';\n            this.text = text;\n            this.previous = previous;\n            this.current = current;\n            this.next = next;\n        }\n        static read(text, startOfLine = false) {\n            startOfLine = startOfLine || breakingWhitespaceRegex.test(text);\n            text = text.trim();\n            for (const rule of rules) {\n                const partial = rule(text);\n                if (partial !== null) {\n                    const token = Object.assign(Object.assign({}, partial), { startOfLine });\n                    text = text.slice(token.text.length);\n                    return { text, token };\n                }\n            }\n            throw new Error('Unexpected Token ' + text);\n        }\n        advance() {\n            const next = Lexer.read(this.text);\n            return new Lexer(next.text, this.current, this.next, next.token);\n        }\n    }\n\n    /**\n     * Throws an error if the provided result is not a {@link RootResult}\n     */\n    function assertRootResult(result) {\n        if (result === undefined) {\n            throw new Error('Unexpected undefined');\n        }\n        if (result.type === 'JsdocTypeKeyValue' || result.type === 'JsdocTypeParameterList' ||\n            result.type === 'JsdocTypeProperty' || result.type === 'JsdocTypeReadonlyProperty' ||\n            result.type === 'JsdocTypeObjectField' || result.type === 'JsdocTypeJsdocObjectField' ||\n            result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertPlainKeyValueOrRootResult(result) {\n        if (result.type === 'JsdocTypeKeyValue') {\n            return assertPlainKeyValueResult(result);\n        }\n        return assertRootResult(result);\n    }\n    function assertPlainKeyValueOrNameResult(result) {\n        if (result.type === 'JsdocTypeName') {\n            return result;\n        }\n        return assertPlainKeyValueResult(result);\n    }\n    function assertPlainKeyValueResult(result) {\n        if (result.type !== 'JsdocTypeKeyValue') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function assertNumberOrVariadicNameResult(result) {\n        var _a;\n        if (result.type === 'JsdocTypeVariadic') {\n            if (((_a = result.element) === null || _a === void 0 ? void 0 : _a.type) === 'JsdocTypeName') {\n                return result;\n            }\n            throw new UnexpectedTypeError(result);\n        }\n        if (result.type !== 'JsdocTypeNumber' && result.type !== 'JsdocTypeName') {\n            throw new UnexpectedTypeError(result);\n        }\n        return result;\n    }\n    function isSquaredProperty(result) {\n        return result.type === 'JsdocTypeIndexSignature' || result.type === 'JsdocTypeMappedType';\n    }\n\n    // higher precedence = higher importance\n    var Precedence;\n    (function (Precedence) {\n        Precedence[Precedence[\"ALL\"] = 0] = \"ALL\";\n        Precedence[Precedence[\"PARAMETER_LIST\"] = 1] = \"PARAMETER_LIST\";\n        Precedence[Precedence[\"OBJECT\"] = 2] = \"OBJECT\";\n        Precedence[Precedence[\"KEY_VALUE\"] = 3] = \"KEY_VALUE\";\n        Precedence[Precedence[\"INDEX_BRACKETS\"] = 4] = \"INDEX_BRACKETS\";\n        Precedence[Precedence[\"UNION\"] = 5] = \"UNION\";\n        Precedence[Precedence[\"INTERSECTION\"] = 6] = \"INTERSECTION\";\n        Precedence[Precedence[\"PREFIX\"] = 7] = \"PREFIX\";\n        Precedence[Precedence[\"INFIX\"] = 8] = \"INFIX\";\n        Precedence[Precedence[\"TUPLE\"] = 9] = \"TUPLE\";\n        Precedence[Precedence[\"SYMBOL\"] = 10] = \"SYMBOL\";\n        Precedence[Precedence[\"OPTIONAL\"] = 11] = \"OPTIONAL\";\n        Precedence[Precedence[\"NULLABLE\"] = 12] = \"NULLABLE\";\n        Precedence[Precedence[\"KEY_OF_TYPE_OF\"] = 13] = \"KEY_OF_TYPE_OF\";\n        Precedence[Precedence[\"FUNCTION\"] = 14] = \"FUNCTION\";\n        Precedence[Precedence[\"ARROW\"] = 15] = \"ARROW\";\n        Precedence[Precedence[\"ARRAY_BRACKETS\"] = 16] = \"ARRAY_BRACKETS\";\n        Precedence[Precedence[\"GENERIC\"] = 17] = \"GENERIC\";\n        Precedence[Precedence[\"NAME_PATH\"] = 18] = \"NAME_PATH\";\n        Precedence[Precedence[\"PARENTHESIS\"] = 19] = \"PARENTHESIS\";\n        Precedence[Precedence[\"SPECIAL_TYPES\"] = 20] = \"SPECIAL_TYPES\";\n    })(Precedence || (Precedence = {}));\n\n    class Parser {\n        constructor(grammar, textOrLexer, baseParser) {\n            this.grammar = grammar;\n            if (typeof textOrLexer === 'string') {\n                this._lexer = Lexer.create(textOrLexer);\n            }\n            else {\n                this._lexer = textOrLexer;\n            }\n            this.baseParser = baseParser;\n        }\n        get lexer() {\n            return this._lexer;\n        }\n        /**\n         * Parses a given string and throws an error if the parse ended before the end of the string.\n         */\n        parse() {\n            const result = this.parseType(Precedence.ALL);\n            if (this.lexer.current.type !== 'EOF') {\n                throw new EarlyEndOfParseError(this.lexer.current);\n            }\n            return result;\n        }\n        /**\n         * Parses with the current lexer and asserts that the result is a {@link RootResult}.\n         */\n        parseType(precedence) {\n            return assertRootResult(this.parseIntermediateType(precedence));\n        }\n        /**\n         * The main parsing function. First it tries to parse the current state in the prefix step, and then it continues\n         * to parse the state in the infix step.\n         */\n        parseIntermediateType(precedence) {\n            const result = this.tryParslets(null, precedence);\n            if (result === null) {\n                throw new NoParsletFoundError(this.lexer.current);\n            }\n            return this.parseInfixIntermediateType(result, precedence);\n        }\n        /**\n         * In the infix parsing step the parser continues to parse the current state with all parslets until none returns\n         * a result.\n         */\n        parseInfixIntermediateType(left, precedence) {\n            let result = this.tryParslets(left, precedence);\n            while (result !== null) {\n                left = result;\n                result = this.tryParslets(left, precedence);\n            }\n            return left;\n        }\n        /**\n         * Tries to parse the current state with all parslets in the grammar and returns the first non null result.\n         */\n        tryParslets(left, precedence) {\n            for (const parslet of this.grammar) {\n                const result = parslet(this, precedence, left);\n                if (result !== null) {\n                    return result;\n                }\n            }\n            return null;\n        }\n        /**\n         * If the given type equals the current type of the {@link Lexer} advance the lexer. Return true if the lexer was\n         * advanced.\n         */\n        consume(types) {\n            if (!Array.isArray(types)) {\n                types = [types];\n            }\n            if (types.includes(this.lexer.current.type)) {\n                this._lexer = this.lexer.advance();\n                return true;\n            }\n            else {\n                return false;\n            }\n        }\n        acceptLexerState(parser) {\n            this._lexer = parser.lexer;\n        }\n    }\n\n    function isQuestionMarkUnknownType(next) {\n        return next === 'EOF' || next === '|' || next === ',' || next === ')' || next === '>';\n    }\n\n    const nullableParslet = (parser, precedence, left) => {\n        const type = parser.lexer.current.type;\n        const next = parser.lexer.next.type;\n        const accept = ((left == null) && type === '?' && !isQuestionMarkUnknownType(next)) ||\n            ((left != null) && type === '?');\n        if (!accept) {\n            return null;\n        }\n        parser.consume('?');\n        if (left == null) {\n            return {\n                type: 'JsdocTypeNullable',\n                element: parser.parseType(Precedence.NULLABLE),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        }\n        else {\n            return {\n                type: 'JsdocTypeNullable',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    };\n\n    function composeParslet(options) {\n        const parslet = (parser, curPrecedence, left) => {\n            const type = parser.lexer.current.type;\n            const next = parser.lexer.next.type;\n            if (left === null) {\n                if ('parsePrefix' in options) {\n                    if (options.accept(type, next)) {\n                        return options.parsePrefix(parser);\n                    }\n                }\n            }\n            else {\n                if ('parseInfix' in options) {\n                    if (options.precedence > curPrecedence && options.accept(type, next)) {\n                        return options.parseInfix(parser, left);\n                    }\n                }\n            }\n            return null;\n        };\n        // for debugging\n        Object.defineProperty(parslet, 'name', {\n            value: options.name\n        });\n        return parslet;\n    }\n\n    const optionalParslet = composeParslet({\n        name: 'optionalParslet',\n        accept: type => type === '=',\n        precedence: Precedence.OPTIONAL,\n        parsePrefix: parser => {\n            parser.consume('=');\n            return {\n                type: 'JsdocTypeOptional',\n                element: parser.parseType(Precedence.OPTIONAL),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        },\n        parseInfix: (parser, left) => {\n            parser.consume('=');\n            return {\n                type: 'JsdocTypeOptional',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    });\n\n    const numberParslet = composeParslet({\n        name: 'numberParslet',\n        accept: type => type === 'Number',\n        parsePrefix: parser => {\n            const value = parseFloat(parser.lexer.current.text);\n            parser.consume('Number');\n            return {\n                type: 'JsdocTypeNumber',\n                value\n            };\n        }\n    });\n\n    const parenthesisParslet = composeParslet({\n        name: 'parenthesisParslet',\n        accept: type => type === '(',\n        parsePrefix: parser => {\n            parser.consume('(');\n            if (parser.consume(')')) {\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements: []\n                };\n            }\n            const result = parser.parseIntermediateType(Precedence.ALL);\n            if (!parser.consume(')')) {\n                throw new Error('Unterminated parenthesis');\n            }\n            if (result.type === 'JsdocTypeParameterList') {\n                return result;\n            }\n            else if (result.type === 'JsdocTypeKeyValue') {\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements: [result]\n                };\n            }\n            return {\n                type: 'JsdocTypeParenthesis',\n                element: assertRootResult(result)\n            };\n        }\n    });\n\n    const specialTypesParslet = composeParslet({\n        name: 'specialTypesParslet',\n        accept: (type, next) => (type === '?' && isQuestionMarkUnknownType(next)) ||\n            type === 'null' || type === 'undefined' || type === '*',\n        parsePrefix: parser => {\n            if (parser.consume('null')) {\n                return {\n                    type: 'JsdocTypeNull'\n                };\n            }\n            if (parser.consume('undefined')) {\n                return {\n                    type: 'JsdocTypeUndefined'\n                };\n            }\n            if (parser.consume('*')) {\n                return {\n                    type: 'JsdocTypeAny'\n                };\n            }\n            if (parser.consume('?')) {\n                return {\n                    type: 'JsdocTypeUnknown'\n                };\n            }\n            throw new Error('Unacceptable token: ' + parser.lexer.current.text);\n        }\n    });\n\n    const notNullableParslet = composeParslet({\n        name: 'notNullableParslet',\n        accept: type => type === '!',\n        precedence: Precedence.NULLABLE,\n        parsePrefix: parser => {\n            parser.consume('!');\n            return {\n                type: 'JsdocTypeNotNullable',\n                element: parser.parseType(Precedence.NULLABLE),\n                meta: {\n                    position: 'prefix'\n                }\n            };\n        },\n        parseInfix: (parser, left) => {\n            parser.consume('!');\n            return {\n                type: 'JsdocTypeNotNullable',\n                element: assertRootResult(left),\n                meta: {\n                    position: 'suffix'\n                }\n            };\n        }\n    });\n\n    function createParameterListParslet({ allowTrailingComma }) {\n        return composeParslet({\n            name: 'parameterListParslet',\n            accept: type => type === ',',\n            precedence: Precedence.PARAMETER_LIST,\n            parseInfix: (parser, left) => {\n                const elements = [\n                    assertPlainKeyValueOrRootResult(left)\n                ];\n                parser.consume(',');\n                do {\n                    try {\n                        const next = parser.parseIntermediateType(Precedence.PARAMETER_LIST);\n                        elements.push(assertPlainKeyValueOrRootResult(next));\n                    }\n                    catch (e) {\n                        if (allowTrailingComma && e instanceof NoParsletFoundError) {\n                            break;\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                } while (parser.consume(','));\n                if (elements.length > 0 && elements.slice(0, -1).some(e => e.type === 'JsdocTypeVariadic')) {\n                    throw new Error('Only the last parameter may be a rest parameter');\n                }\n                return {\n                    type: 'JsdocTypeParameterList',\n                    elements\n                };\n            }\n        });\n    }\n\n    const genericParslet = composeParslet({\n        name: 'genericParslet',\n        accept: (type, next) => type === '<' || (type === '.' && next === '<'),\n        precedence: Precedence.GENERIC,\n        parseInfix: (parser, left) => {\n            const dot = parser.consume('.');\n            parser.consume('<');\n            const objects = [];\n            do {\n                objects.push(parser.parseType(Precedence.PARAMETER_LIST));\n            } while (parser.consume(','));\n            if (!parser.consume('>')) {\n                throw new Error('Unterminated generic parameter list');\n            }\n            return {\n                type: 'JsdocTypeGeneric',\n                left: assertRootResult(left),\n                elements: objects,\n                meta: {\n                    brackets: 'angle',\n                    dot\n                }\n            };\n        }\n    });\n\n    const unionParslet = composeParslet({\n        name: 'unionParslet',\n        accept: type => type === '|',\n        precedence: Precedence.UNION,\n        parseInfix: (parser, left) => {\n            parser.consume('|');\n            const elements = [];\n            do {\n                elements.push(parser.parseType(Precedence.UNION));\n            } while (parser.consume('|'));\n            return {\n                type: 'JsdocTypeUnion',\n                elements: [assertRootResult(left), ...elements]\n            };\n        }\n    });\n\n    const baseGrammar = [\n        nullableParslet,\n        optionalParslet,\n        numberParslet,\n        parenthesisParslet,\n        specialTypesParslet,\n        notNullableParslet,\n        createParameterListParslet({\n            allowTrailingComma: true\n        }),\n        genericParslet,\n        unionParslet,\n        optionalParslet\n    ];\n\n    function createNamePathParslet({ allowSquareBracketsOnAnyType, allowJsdocNamePaths, pathGrammar }) {\n        return function namePathParslet(parser, precedence, left) {\n            if ((left == null) || precedence >= Precedence.NAME_PATH) {\n                return null;\n            }\n            const type = parser.lexer.current.type;\n            const next = parser.lexer.next.type;\n            const accept = (type === '.' && next !== '<') ||\n                (type === '[' && (allowSquareBracketsOnAnyType || left.type === 'JsdocTypeName')) ||\n                (allowJsdocNamePaths && (type === '~' || type === '#'));\n            if (!accept) {\n                return null;\n            }\n            let pathType;\n            let brackets = false;\n            if (parser.consume('.')) {\n                pathType = 'property';\n            }\n            else if (parser.consume('[')) {\n                pathType = 'property-brackets';\n                brackets = true;\n            }\n            else if (parser.consume('~')) {\n                pathType = 'inner';\n            }\n            else {\n                parser.consume('#');\n                pathType = 'instance';\n            }\n            const pathParser = pathGrammar !== null\n                ? new Parser(pathGrammar, parser.lexer, parser)\n                : parser;\n            const parsed = pathParser.parseIntermediateType(Precedence.NAME_PATH);\n            parser.acceptLexerState(pathParser);\n            let right;\n            switch (parsed.type) {\n                case 'JsdocTypeName':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value,\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                    break;\n                case 'JsdocTypeNumber':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value.toString(10),\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                    break;\n                case 'JsdocTypeStringValue':\n                    right = {\n                        type: 'JsdocTypeProperty',\n                        value: parsed.value,\n                        meta: {\n                            quote: parsed.meta.quote\n                        }\n                    };\n                    break;\n                case 'JsdocTypeSpecialNamePath':\n                    if (parsed.specialType === 'event') {\n                        right = parsed;\n                    }\n                    else {\n                        throw new UnexpectedTypeError(parsed, 'Type \\'JsdocTypeSpecialNamePath\\' is only allowed with specialType \\'event\\'');\n                    }\n                    break;\n                default:\n                    throw new UnexpectedTypeError(parsed, 'Expecting \\'JsdocTypeName\\', \\'JsdocTypeNumber\\', \\'JsdocStringValue\\' or \\'JsdocTypeSpecialNamePath\\'');\n            }\n            if (brackets && !parser.consume(']')) {\n                const token = parser.lexer.current;\n                throw new Error(`Unterminated square brackets. Next token is '${token.type}' ` +\n                    `with text '${token.text}'`);\n            }\n            return {\n                type: 'JsdocTypeNamePath',\n                left: assertRootResult(left),\n                right,\n                pathType\n            };\n        };\n    }\n\n    function createNameParslet({ allowedAdditionalTokens }) {\n        return composeParslet({\n            name: 'nameParslet',\n            accept: type => type === 'Identifier' || type === 'this' || type === 'new' || allowedAdditionalTokens.includes(type),\n            parsePrefix: parser => {\n                const { type, text } = parser.lexer.current;\n                parser.consume(type);\n                return {\n                    type: 'JsdocTypeName',\n                    value: text\n                };\n            }\n        });\n    }\n\n    const stringValueParslet = composeParslet({\n        name: 'stringValueParslet',\n        accept: type => type === 'StringValue',\n        parsePrefix: parser => {\n            const text = parser.lexer.current.text;\n            parser.consume('StringValue');\n            return {\n                type: 'JsdocTypeStringValue',\n                value: text.slice(1, -1),\n                meta: {\n                    quote: text[0] === '\\'' ? 'single' : 'double'\n                }\n            };\n        }\n    });\n\n    function createSpecialNamePathParslet({ pathGrammar, allowedTypes }) {\n        return composeParslet({\n            name: 'specialNamePathParslet',\n            accept: type => allowedTypes.includes(type),\n            parsePrefix: parser => {\n                const type = parser.lexer.current.type;\n                parser.consume(type);\n                if (!parser.consume(':')) {\n                    return {\n                        type: 'JsdocTypeName',\n                        value: type\n                    };\n                }\n                let result;\n                let token = parser.lexer.current;\n                if (parser.consume('StringValue')) {\n                    result = {\n                        type: 'JsdocTypeSpecialNamePath',\n                        value: token.text.slice(1, -1),\n                        specialType: type,\n                        meta: {\n                            quote: token.text[0] === '\\'' ? 'single' : 'double'\n                        }\n                    };\n                }\n                else {\n                    let value = '';\n                    const allowed = ['Identifier', '@', '/'];\n                    while (allowed.some(type => parser.consume(type))) {\n                        value += token.text;\n                        token = parser.lexer.current;\n                    }\n                    result = {\n                        type: 'JsdocTypeSpecialNamePath',\n                        value,\n                        specialType: type,\n                        meta: {\n                            quote: undefined\n                        }\n                    };\n                }\n                const moduleParser = new Parser(pathGrammar, parser.lexer, parser);\n                const moduleResult = moduleParser.parseInfixIntermediateType(result, Precedence.ALL);\n                parser.acceptLexerState(moduleParser);\n                return assertRootResult(moduleResult);\n            }\n        });\n    }\n\n    const basePathGrammar = [\n        createNameParslet({\n            allowedAdditionalTokens: ['external', 'module']\n        }),\n        stringValueParslet,\n        numberParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar: null\n        })\n    ];\n    const pathGrammar = [\n        ...basePathGrammar,\n        createSpecialNamePathParslet({\n            allowedTypes: ['event'],\n            pathGrammar: basePathGrammar\n        })\n    ];\n\n    function getParameters(value) {\n        let parameters;\n        if (value.type === 'JsdocTypeParameterList') {\n            parameters = value.elements;\n        }\n        else if (value.type === 'JsdocTypeParenthesis') {\n            parameters = [value.element];\n        }\n        else {\n            throw new UnexpectedTypeError(value);\n        }\n        return parameters.map(p => assertPlainKeyValueOrRootResult(p));\n    }\n    function getUnnamedParameters(value) {\n        const parameters = getParameters(value);\n        if (parameters.some(p => p.type === 'JsdocTypeKeyValue')) {\n            throw new Error('No parameter should be named');\n        }\n        return parameters;\n    }\n    function createFunctionParslet({ allowNamedParameters, allowNoReturnType, allowWithoutParenthesis, allowNewAsFunctionKeyword }) {\n        return composeParslet({\n            name: 'functionParslet',\n            accept: (type, next) => type === 'function' || (allowNewAsFunctionKeyword && type === 'new' && next === '('),\n            parsePrefix: parser => {\n                const newKeyword = parser.consume('new');\n                parser.consume('function');\n                const hasParenthesis = parser.lexer.current.type === '(';\n                if (!hasParenthesis) {\n                    if (!allowWithoutParenthesis) {\n                        throw new Error('function is missing parameter list');\n                    }\n                    return {\n                        type: 'JsdocTypeName',\n                        value: 'function'\n                    };\n                }\n                let result = {\n                    type: 'JsdocTypeFunction',\n                    parameters: [],\n                    arrow: false,\n                    constructor: newKeyword,\n                    parenthesis: hasParenthesis\n                };\n                const value = parser.parseIntermediateType(Precedence.FUNCTION);\n                if (allowNamedParameters === undefined) {\n                    result.parameters = getUnnamedParameters(value);\n                }\n                else if (newKeyword && value.type === 'JsdocTypeFunction' && value.arrow) {\n                    result = value;\n                    result.constructor = true;\n                    return result;\n                }\n                else {\n                    result.parameters = getParameters(value);\n                    for (const p of result.parameters) {\n                        if (p.type === 'JsdocTypeKeyValue' && (!allowNamedParameters.includes(p.key))) {\n                            throw new Error(`only allowed named parameters are ${allowNamedParameters.join(', ')} but got ${p.type}`);\n                        }\n                    }\n                }\n                if (parser.consume(':')) {\n                    result.returnType = parser.parseType(Precedence.PREFIX);\n                }\n                else {\n                    if (!allowNoReturnType) {\n                        throw new Error('function is missing return type');\n                    }\n                }\n                return result;\n            }\n        });\n    }\n\n    function createVariadicParslet({ allowPostfix, allowEnclosingBrackets }) {\n        return composeParslet({\n            name: 'variadicParslet',\n            accept: type => type === '...',\n            precedence: Precedence.PREFIX,\n            parsePrefix: parser => {\n                parser.consume('...');\n                const brackets = allowEnclosingBrackets && parser.consume('[');\n                try {\n                    const element = parser.parseType(Precedence.PREFIX);\n                    if (brackets && !parser.consume(']')) {\n                        throw new Error('Unterminated variadic type. Missing \\']\\'');\n                    }\n                    return {\n                        type: 'JsdocTypeVariadic',\n                        element: assertRootResult(element),\n                        meta: {\n                            position: 'prefix',\n                            squareBrackets: brackets\n                        }\n                    };\n                }\n                catch (e) {\n                    if (e instanceof NoParsletFoundError) {\n                        if (brackets) {\n                            throw new Error('Empty square brackets for variadic are not allowed.');\n                        }\n                        return {\n                            type: 'JsdocTypeVariadic',\n                            meta: {\n                                position: undefined,\n                                squareBrackets: false\n                            }\n                        };\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            },\n            parseInfix: allowPostfix\n                ? (parser, left) => {\n                    parser.consume('...');\n                    return {\n                        type: 'JsdocTypeVariadic',\n                        element: assertRootResult(left),\n                        meta: {\n                            position: 'suffix',\n                            squareBrackets: false\n                        }\n                    };\n                }\n                : undefined\n        });\n    }\n\n    const symbolParslet = composeParslet({\n        name: 'symbolParslet',\n        accept: type => type === '(',\n        precedence: Precedence.SYMBOL,\n        parseInfix: (parser, left) => {\n            if (left.type !== 'JsdocTypeName') {\n                throw new Error('Symbol expects a name on the left side. (Reacting on \\'(\\')');\n            }\n            parser.consume('(');\n            const result = {\n                type: 'JsdocTypeSymbol',\n                value: left.value\n            };\n            if (!parser.consume(')')) {\n                const next = parser.parseIntermediateType(Precedence.SYMBOL);\n                result.element = assertNumberOrVariadicNameResult(next);\n                if (!parser.consume(')')) {\n                    throw new Error('Symbol does not end after value');\n                }\n            }\n            return result;\n        }\n    });\n\n    const arrayBracketsParslet = composeParslet({\n        name: 'arrayBracketsParslet',\n        precedence: Precedence.ARRAY_BRACKETS,\n        accept: (type, next) => type === '[' && next === ']',\n        parseInfix: (parser, left) => {\n            parser.consume('[');\n            parser.consume(']');\n            return {\n                type: 'JsdocTypeGeneric',\n                left: {\n                    type: 'JsdocTypeName',\n                    value: 'Array'\n                },\n                elements: [\n                    assertRootResult(left)\n                ],\n                meta: {\n                    brackets: 'square',\n                    dot: false\n                }\n            };\n        }\n    });\n\n    function createObjectParslet({ objectFieldGrammar, allowKeyTypes }) {\n        return composeParslet({\n            name: 'objectParslet',\n            accept: type => type === '{',\n            parsePrefix: parser => {\n                parser.consume('{');\n                const result = {\n                    type: 'JsdocTypeObject',\n                    meta: {\n                        separator: 'comma'\n                    },\n                    elements: []\n                };\n                if (!parser.consume('}')) {\n                    let separator;\n                    const fieldParser = new Parser(objectFieldGrammar, parser.lexer, parser);\n                    while (true) {\n                        fieldParser.acceptLexerState(parser);\n                        let field = fieldParser.parseIntermediateType(Precedence.OBJECT);\n                        parser.acceptLexerState(fieldParser);\n                        if (field === undefined && allowKeyTypes) {\n                            field = parser.parseIntermediateType(Precedence.OBJECT);\n                        }\n                        let optional = false;\n                        if (field.type === 'JsdocTypeNullable') {\n                            optional = true;\n                            field = field.element;\n                        }\n                        if (field.type === 'JsdocTypeNumber' || field.type === 'JsdocTypeName' || field.type === 'JsdocTypeStringValue') {\n                            let quote;\n                            if (field.type === 'JsdocTypeStringValue') {\n                                quote = field.meta.quote;\n                            }\n                            result.elements.push({\n                                type: 'JsdocTypeObjectField',\n                                key: field.value.toString(),\n                                right: undefined,\n                                optional,\n                                readonly: false,\n                                meta: {\n                                    quote\n                                }\n                            });\n                        }\n                        else if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n                            result.elements.push(field);\n                        }\n                        else {\n                            throw new UnexpectedTypeError(field);\n                        }\n                        if (parser.lexer.current.startOfLine) {\n                            separator = 'linebreak';\n                        }\n                        else if (parser.consume(',')) {\n                            separator = 'comma';\n                        }\n                        else if (parser.consume(';')) {\n                            separator = 'semicolon';\n                        }\n                        else {\n                            break;\n                        }\n                        const type = parser.lexer.current.type;\n                        if (type === '}') {\n                            break;\n                        }\n                    }\n                    result.meta.separator = separator !== null && separator !== void 0 ? separator : 'comma'; // TODO: use undefined here\n                    if (!parser.consume('}')) {\n                        throw new Error('Unterminated record type. Missing \\'}\\'');\n                    }\n                }\n                return result;\n            }\n        });\n    }\n\n    function createObjectFieldParslet({ allowSquaredProperties, allowKeyTypes, allowReadonly, allowOptional }) {\n        return composeParslet({\n            name: 'objectFieldParslet',\n            precedence: Precedence.KEY_VALUE,\n            accept: type => type === ':',\n            parseInfix: (parser, left) => {\n                var _a;\n                let optional = false;\n                let readonlyProperty = false;\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\n                    optional = true;\n                    left = left.element;\n                }\n                if (allowReadonly && left.type === 'JsdocTypeReadonlyProperty') {\n                    readonlyProperty = true;\n                    left = left.element;\n                }\n                // object parslet uses a special grammar and for the value we want to switch back to the parent\n                const parentParser = (_a = parser.baseParser) !== null && _a !== void 0 ? _a : parser;\n                parentParser.acceptLexerState(parser);\n                if (left.type === 'JsdocTypeNumber' || left.type === 'JsdocTypeName' || left.type === 'JsdocTypeStringValue' ||\n                    isSquaredProperty(left)) {\n                    if (isSquaredProperty(left) && !allowSquaredProperties) {\n                        throw new UnexpectedTypeError(left);\n                    }\n                    parentParser.consume(':');\n                    let quote;\n                    if (left.type === 'JsdocTypeStringValue') {\n                        quote = left.meta.quote;\n                    }\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\n                    parser.acceptLexerState(parentParser);\n                    return {\n                        type: 'JsdocTypeObjectField',\n                        key: isSquaredProperty(left) ? left : left.value.toString(),\n                        right,\n                        optional,\n                        readonly: readonlyProperty,\n                        meta: {\n                            quote\n                        }\n                    };\n                }\n                else {\n                    if (!allowKeyTypes) {\n                        throw new UnexpectedTypeError(left);\n                    }\n                    parentParser.consume(':');\n                    const right = parentParser.parseType(Precedence.KEY_VALUE);\n                    parser.acceptLexerState(parentParser);\n                    return {\n                        type: 'JsdocTypeJsdocObjectField',\n                        left: assertRootResult(left),\n                        right\n                    };\n                }\n            }\n        });\n    }\n\n    function createKeyValueParslet({ allowOptional, allowVariadic }) {\n        return composeParslet({\n            name: 'keyValueParslet',\n            precedence: Precedence.KEY_VALUE,\n            accept: type => type === ':',\n            parseInfix: (parser, left) => {\n                let optional = false;\n                let variadic = false;\n                if (allowOptional && left.type === 'JsdocTypeNullable') {\n                    optional = true;\n                    left = left.element;\n                }\n                if (allowVariadic && left.type === 'JsdocTypeVariadic' && left.element !== undefined) {\n                    variadic = true;\n                    left = left.element;\n                }\n                if (left.type !== 'JsdocTypeName') {\n                    throw new UnexpectedTypeError(left);\n                }\n                parser.consume(':');\n                const right = parser.parseType(Precedence.KEY_VALUE);\n                return {\n                    type: 'JsdocTypeKeyValue',\n                    key: left.value,\n                    right,\n                    optional,\n                    variadic\n                };\n            }\n        });\n    }\n\n    const jsdocBaseGrammar = [\n        ...baseGrammar,\n        createFunctionParslet({\n            allowWithoutParenthesis: true,\n            allowNamedParameters: ['this', 'new'],\n            allowNoReturnType: true,\n            allowNewAsFunctionKeyword: false\n        }),\n        stringValueParslet,\n        createSpecialNamePathParslet({\n            allowedTypes: ['module', 'external', 'event'],\n            pathGrammar\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: true,\n            allowPostfix: true\n        }),\n        createNameParslet({\n            allowedAdditionalTokens: ['keyof']\n        }),\n        symbolParslet,\n        arrayBracketsParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar\n        })\n    ];\n    const jsdocGrammar = [\n        ...jsdocBaseGrammar,\n        createObjectParslet({\n            // jsdoc syntax allows full types as keys, so we need to pull in the full grammar here\n            // we leave out the object type deliberately\n            objectFieldGrammar: [\n                createNameParslet({\n                    allowedAdditionalTokens: ['module', 'in']\n                }),\n                createObjectFieldParslet({\n                    allowSquaredProperties: false,\n                    allowKeyTypes: true,\n                    allowOptional: false,\n                    allowReadonly: false\n                }),\n                ...jsdocBaseGrammar\n            ],\n            allowKeyTypes: true\n        }),\n        createKeyValueParslet({\n            allowOptional: true,\n            allowVariadic: true\n        })\n    ];\n\n    const typeOfParslet = composeParslet({\n        name: 'typeOfParslet',\n        accept: type => type === 'typeof',\n        parsePrefix: parser => {\n            parser.consume('typeof');\n            return {\n                type: 'JsdocTypeTypeof',\n                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n            };\n        }\n    });\n\n    const objectFieldGrammar$1 = [\n        createNameParslet({\n            allowedAdditionalTokens: ['module', 'keyof', 'event', 'external', 'in']\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n            allowSquaredProperties: false,\n            allowKeyTypes: false,\n            allowOptional: false,\n            allowReadonly: false\n        })\n    ];\n    const closureGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n            allowKeyTypes: false,\n            objectFieldGrammar: objectFieldGrammar$1\n        }),\n        createNameParslet({\n            allowedAdditionalTokens: ['event', 'external', 'in']\n        }),\n        typeOfParslet,\n        createFunctionParslet({\n            allowWithoutParenthesis: false,\n            allowNamedParameters: ['this', 'new'],\n            allowNoReturnType: true,\n            allowNewAsFunctionKeyword: false\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: false,\n            allowPostfix: false\n        }),\n        // additional name parslet is needed for some special cases\n        createNameParslet({\n            allowedAdditionalTokens: ['keyof']\n        }),\n        createSpecialNamePathParslet({\n            allowedTypes: ['module'],\n            pathGrammar\n        }),\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: false,\n            allowJsdocNamePaths: true,\n            pathGrammar\n        }),\n        createKeyValueParslet({\n            allowOptional: false,\n            allowVariadic: false\n        }),\n        symbolParslet\n    ];\n\n    const assertsParslet = composeParslet({\n        name: 'assertsParslet',\n        accept: type => type === 'asserts',\n        parsePrefix: (parser) => {\n            parser.consume('asserts');\n            const left = parser.parseIntermediateType(Precedence.SYMBOL);\n            if (left.type !== 'JsdocTypeName') {\n                throw new UnexpectedTypeError(left, 'A typescript asserts always has to have a name on the left side.');\n            }\n            parser.consume('is');\n            return {\n                type: 'JsdocTypeAsserts',\n                left,\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            };\n        }\n    });\n\n    function createTupleParslet({ allowQuestionMark }) {\n        return composeParslet({\n            name: 'tupleParslet',\n            accept: type => type === '[',\n            parsePrefix: parser => {\n                parser.consume('[');\n                const result = {\n                    type: 'JsdocTypeTuple',\n                    elements: []\n                };\n                if (parser.consume(']')) {\n                    return result;\n                }\n                const typeList = parser.parseIntermediateType(Precedence.ALL);\n                if (typeList.type === 'JsdocTypeParameterList') {\n                    if (typeList.elements[0].type === 'JsdocTypeKeyValue') {\n                        result.elements = typeList.elements.map(assertPlainKeyValueResult);\n                    }\n                    else {\n                        result.elements = typeList.elements.map(assertRootResult);\n                    }\n                }\n                else {\n                    if (typeList.type === 'JsdocTypeKeyValue') {\n                        result.elements = [assertPlainKeyValueResult(typeList)];\n                    }\n                    else {\n                        result.elements = [assertRootResult(typeList)];\n                    }\n                }\n                if (!parser.consume(']')) {\n                    throw new Error('Unterminated \\'[\\'');\n                }\n                if (!allowQuestionMark && result.elements.some((e) => e.type === 'JsdocTypeUnknown')) {\n                    throw new Error('Question mark in tuple not allowed');\n                }\n                return result;\n            }\n        });\n    }\n\n    const keyOfParslet = composeParslet({\n        name: 'keyOfParslet',\n        accept: type => type === 'keyof',\n        parsePrefix: parser => {\n            parser.consume('keyof');\n            return {\n                type: 'JsdocTypeKeyof',\n                element: assertRootResult(parser.parseType(Precedence.KEY_OF_TYPE_OF))\n            };\n        }\n    });\n\n    const importParslet = composeParslet({\n        name: 'importParslet',\n        accept: type => type === 'import',\n        parsePrefix: parser => {\n            parser.consume('import');\n            if (!parser.consume('(')) {\n                throw new Error('Missing parenthesis after import keyword');\n            }\n            const path = parser.parseType(Precedence.PREFIX);\n            if (path.type !== 'JsdocTypeStringValue') {\n                throw new Error('Only string values are allowed as paths for imports');\n            }\n            if (!parser.consume(')')) {\n                throw new Error('Missing closing parenthesis after import keyword');\n            }\n            return {\n                type: 'JsdocTypeImport',\n                element: path\n            };\n        }\n    });\n\n    const readonlyPropertyParslet = composeParslet({\n        name: 'readonlyPropertyParslet',\n        accept: type => type === 'readonly',\n        parsePrefix: parser => {\n            parser.consume('readonly');\n            return {\n                type: 'JsdocTypeReadonlyProperty',\n                element: parser.parseType(Precedence.KEY_VALUE)\n            };\n        }\n    });\n\n    const arrowFunctionParslet = composeParslet({\n        name: 'arrowFunctionParslet',\n        precedence: Precedence.ARROW,\n        accept: type => type === '=>',\n        parseInfix: (parser, left) => {\n            parser.consume('=>');\n            return {\n                type: 'JsdocTypeFunction',\n                parameters: getParameters(left).map(assertPlainKeyValueOrNameResult),\n                arrow: true,\n                constructor: false,\n                parenthesis: true,\n                returnType: parser.parseType(Precedence.OBJECT)\n            };\n        }\n    });\n\n    const intersectionParslet = composeParslet({\n        name: 'intersectionParslet',\n        accept: type => type === '&',\n        precedence: Precedence.INTERSECTION,\n        parseInfix: (parser, left) => {\n            parser.consume('&');\n            const elements = [];\n            do {\n                elements.push(parser.parseType(Precedence.INTERSECTION));\n            } while (parser.consume('&'));\n            return {\n                type: 'JsdocTypeIntersection',\n                elements: [assertRootResult(left), ...elements]\n            };\n        }\n    });\n\n    const predicateParslet = composeParslet({\n        name: 'predicateParslet',\n        precedence: Precedence.INFIX,\n        accept: type => type === 'is',\n        parseInfix: (parser, left) => {\n            if (left.type !== 'JsdocTypeName') {\n                throw new UnexpectedTypeError(left, 'A typescript predicate always has to have a name on the left side.');\n            }\n            parser.consume('is');\n            return {\n                type: 'JsdocTypePredicate',\n                left,\n                right: assertRootResult(parser.parseIntermediateType(Precedence.INFIX))\n            };\n        }\n    });\n\n    const objectSquaredPropertyParslet = composeParslet({\n        name: 'objectSquareBracketPropertyParslet',\n        accept: type => type === '[',\n        parsePrefix: parser => {\n            if (parser.baseParser === undefined) {\n                throw new Error('Only allowed inside object grammar');\n            }\n            parser.consume('[');\n            const key = parser.lexer.current.text;\n            parser.consume('Identifier');\n            let result;\n            if (parser.consume(':')) {\n                const parentParser = parser.baseParser;\n                parentParser.acceptLexerState(parser);\n                result = {\n                    type: 'JsdocTypeIndexSignature',\n                    key,\n                    right: parentParser.parseType(Precedence.INDEX_BRACKETS)\n                };\n                parser.acceptLexerState(parentParser);\n            }\n            else if (parser.consume('in')) {\n                const parentParser = parser.baseParser;\n                parentParser.acceptLexerState(parser);\n                result = {\n                    type: 'JsdocTypeMappedType',\n                    key,\n                    right: parentParser.parseType(Precedence.ARRAY_BRACKETS)\n                };\n                parser.acceptLexerState(parentParser);\n            }\n            else {\n                throw new Error('Missing \\':\\' or \\'in\\' inside square bracketed property.');\n            }\n            if (!parser.consume(']')) {\n                throw new Error('Unterminated square brackets');\n            }\n            return result;\n        }\n    });\n\n    const objectFieldGrammar = [\n        readonlyPropertyParslet,\n        createNameParslet({\n            allowedAdditionalTokens: ['module', 'event', 'keyof', 'event', 'external', 'in']\n        }),\n        nullableParslet,\n        optionalParslet,\n        stringValueParslet,\n        numberParslet,\n        createObjectFieldParslet({\n            allowSquaredProperties: true,\n            allowKeyTypes: false,\n            allowOptional: true,\n            allowReadonly: true\n        }),\n        objectSquaredPropertyParslet\n    ];\n    const typescriptGrammar = [\n        ...baseGrammar,\n        createObjectParslet({\n            allowKeyTypes: false,\n            objectFieldGrammar\n        }),\n        typeOfParslet,\n        keyOfParslet,\n        importParslet,\n        stringValueParslet,\n        createFunctionParslet({\n            allowWithoutParenthesis: true,\n            allowNoReturnType: false,\n            allowNamedParameters: ['this', 'new', 'args'],\n            allowNewAsFunctionKeyword: true\n        }),\n        createTupleParslet({\n            allowQuestionMark: false\n        }),\n        createVariadicParslet({\n            allowEnclosingBrackets: false,\n            allowPostfix: false\n        }),\n        assertsParslet,\n        createNameParslet({\n            allowedAdditionalTokens: ['event', 'external', 'in']\n        }),\n        createSpecialNamePathParslet({\n            allowedTypes: ['module'],\n            pathGrammar\n        }),\n        arrayBracketsParslet,\n        arrowFunctionParslet,\n        createNamePathParslet({\n            allowSquareBracketsOnAnyType: true,\n            allowJsdocNamePaths: false,\n            pathGrammar\n        }),\n        intersectionParslet,\n        predicateParslet,\n        createKeyValueParslet({\n            allowVariadic: true,\n            allowOptional: true\n        })\n    ];\n\n    /**\n     * This function parses the given expression in the given mode and produces a {@link RootResult}.\n     * @param expression\n     * @param mode\n     */\n    function parse(expression, mode) {\n        switch (mode) {\n            case 'closure':\n                return (new Parser(closureGrammar, expression)).parse();\n            case 'jsdoc':\n                return (new Parser(jsdocGrammar, expression)).parse();\n            case 'typescript':\n                return (new Parser(typescriptGrammar, expression)).parse();\n        }\n    }\n    /**\n     * This function tries to parse the given expression in multiple modes and returns the first successful\n     * {@link RootResult}. By default it tries `'typescript'`, `'closure'` and `'jsdoc'` in this order. If\n     * no mode was successful it throws the error that was produced by the last parsing attempt.\n     * @param expression\n     * @param modes\n     */\n    function tryParse(expression, modes = ['typescript', 'closure', 'jsdoc']) {\n        let error;\n        for (const mode of modes) {\n            try {\n                return parse(expression, mode);\n            }\n            catch (e) {\n                error = e;\n            }\n        }\n        throw error;\n    }\n\n    function transform(rules, parseResult) {\n        const rule = rules[parseResult.type];\n        if (rule === undefined) {\n            throw new Error(`In this set of transform rules exists no rule for type ${parseResult.type}.`);\n        }\n        return rule(parseResult, aParseResult => transform(rules, aParseResult));\n    }\n    function notAvailableTransform(parseResult) {\n        throw new Error('This transform is not available. Are you trying the correct parsing mode?');\n    }\n    function extractSpecialParams(source) {\n        const result = {\n            params: []\n        };\n        for (const param of source.parameters) {\n            if (param.type === 'JsdocTypeKeyValue') {\n                if (param.key === 'this') {\n                    result.this = param.right;\n                }\n                else if (param.key === 'new') {\n                    result.new = param.right;\n                }\n                else {\n                    result.params.push(param);\n                }\n            }\n            else {\n                result.params.push(param);\n            }\n        }\n        return result;\n    }\n\n    function applyPosition(position, target, value) {\n        return position === 'prefix' ? value + target : target + value;\n    }\n    function quote(value, quote) {\n        switch (quote) {\n            case 'double':\n                return `\"${value}\"`;\n            case 'single':\n                return `'${value}'`;\n            case undefined:\n                return value;\n        }\n    }\n    function stringifyRules() {\n        return {\n            JsdocTypeParenthesis: (result, transform) => `(${result.element !== undefined ? transform(result.element) : ''})`,\n            JsdocTypeKeyof: (result, transform) => `keyof ${transform(result.element)}`,\n            JsdocTypeFunction: (result, transform) => {\n                if (!result.arrow) {\n                    let stringified = result.constructor ? 'new' : 'function';\n                    if (!result.parenthesis) {\n                        return stringified;\n                    }\n                    stringified += `(${result.parameters.map(transform).join(', ')})`;\n                    if (result.returnType !== undefined) {\n                        stringified += `: ${transform(result.returnType)}`;\n                    }\n                    return stringified;\n                }\n                else {\n                    if (result.returnType === undefined) {\n                        throw new Error('Arrow function needs a return type.');\n                    }\n                    let stringified = `(${result.parameters.map(transform).join(', ')}) => ${transform(result.returnType)}`;\n                    if (result.constructor) {\n                        stringified = 'new ' + stringified;\n                    }\n                    return stringified;\n                }\n            },\n            JsdocTypeName: result => result.value,\n            JsdocTypeTuple: (result, transform) => `[${result.elements.map(transform).join(', ')}]`,\n            JsdocTypeVariadic: (result, transform) => result.meta.position === undefined\n                ? '...'\n                : applyPosition(result.meta.position, transform(result.element), '...'),\n            JsdocTypeNamePath: (result, transform) => {\n                const left = transform(result.left);\n                const right = transform(result.right);\n                switch (result.pathType) {\n                    case 'inner':\n                        return `${left}~${right}`;\n                    case 'instance':\n                        return `${left}#${right}`;\n                    case 'property':\n                        return `${left}.${right}`;\n                    case 'property-brackets':\n                        return `${left}[${right}]`;\n                }\n            },\n            JsdocTypeStringValue: result => quote(result.value, result.meta.quote),\n            JsdocTypeAny: () => '*',\n            JsdocTypeGeneric: (result, transform) => {\n                if (result.meta.brackets === 'square') {\n                    const element = result.elements[0];\n                    const transformed = transform(element);\n                    if (element.type === 'JsdocTypeUnion' || element.type === 'JsdocTypeIntersection') {\n                        return `(${transformed})[]`;\n                    }\n                    else {\n                        return `${transformed}[]`;\n                    }\n                }\n                else {\n                    return `${transform(result.left)}${result.meta.dot ? '.' : ''}<${result.elements.map(transform).join(', ')}>`;\n                }\n            },\n            JsdocTypeImport: (result, transform) => `import(${transform(result.element)})`,\n            JsdocTypeObjectField: (result, transform) => {\n                let text = '';\n                if (result.readonly) {\n                    text += 'readonly ';\n                }\n                if (typeof result.key === 'string') {\n                    text += quote(result.key, result.meta.quote);\n                }\n                else {\n                    text += transform(result.key);\n                }\n                if (result.optional) {\n                    text += '?';\n                }\n                if (result.right === undefined) {\n                    return text;\n                }\n                else {\n                    return text + `: ${transform(result.right)}`;\n                }\n            },\n            JsdocTypeJsdocObjectField: (result, transform) => {\n                return `${transform(result.left)}: ${transform(result.right)}`;\n            },\n            JsdocTypeKeyValue: (result, transform) => {\n                let text = result.key;\n                if (result.optional) {\n                    text += '?';\n                }\n                if (result.variadic) {\n                    text = '...' + text;\n                }\n                if (result.right === undefined) {\n                    return text;\n                }\n                else {\n                    return text + `: ${transform(result.right)}`;\n                }\n            },\n            JsdocTypeSpecialNamePath: result => `${result.specialType}:${quote(result.value, result.meta.quote)}`,\n            JsdocTypeNotNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '!'),\n            JsdocTypeNull: () => 'null',\n            JsdocTypeNullable: (result, transform) => applyPosition(result.meta.position, transform(result.element), '?'),\n            JsdocTypeNumber: result => result.value.toString(),\n            JsdocTypeObject: (result, transform) => `{${result.elements.map(transform).join((result.meta.separator === 'comma' ? ',' : ';') + ' ')}}`,\n            JsdocTypeOptional: (result, transform) => applyPosition(result.meta.position, transform(result.element), '='),\n            JsdocTypeSymbol: (result, transform) => `${result.value}(${result.element !== undefined ? transform(result.element) : ''})`,\n            JsdocTypeTypeof: (result, transform) => `typeof ${transform(result.element)}`,\n            JsdocTypeUndefined: () => 'undefined',\n            JsdocTypeUnion: (result, transform) => result.elements.map(transform).join(' | '),\n            JsdocTypeUnknown: () => '?',\n            JsdocTypeIntersection: (result, transform) => result.elements.map(transform).join(' & '),\n            JsdocTypeProperty: result => quote(result.value, result.meta.quote),\n            JsdocTypePredicate: (result, transform) => `${transform(result.left)} is ${transform(result.right)}`,\n            JsdocTypeIndexSignature: (result, transform) => `[${result.key}: ${transform(result.right)}]`,\n            JsdocTypeMappedType: (result, transform) => `[${result.key} in ${transform(result.right)}]`,\n            JsdocTypeAsserts: (result, transform) => `asserts ${transform(result.left)} is ${transform(result.right)}`\n        };\n    }\n    const storedStringifyRules = stringifyRules();\n    function stringify(result) {\n        return transform(storedStringifyRules, result);\n    }\n\n    const reservedWords = [\n        'null',\n        'true',\n        'false',\n        'break',\n        'case',\n        'catch',\n        'class',\n        'const',\n        'continue',\n        'debugger',\n        'default',\n        'delete',\n        'do',\n        'else',\n        'export',\n        'extends',\n        'finally',\n        'for',\n        'function',\n        'if',\n        'import',\n        'in',\n        'instanceof',\n        'new',\n        'return',\n        'super',\n        'switch',\n        'this',\n        'throw',\n        'try',\n        'typeof',\n        'var',\n        'void',\n        'while',\n        'with',\n        'yield'\n    ];\n    function makeName(value) {\n        const result = {\n            type: 'NameExpression',\n            name: value\n        };\n        if (reservedWords.includes(value)) {\n            result.reservedWord = true;\n        }\n        return result;\n    }\n    const catharsisTransformRules = {\n        JsdocTypeOptional: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.optional = true;\n            return transformed;\n        },\n        JsdocTypeNullable: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.nullable = true;\n            return transformed;\n        },\n        JsdocTypeNotNullable: (result, transform) => {\n            const transformed = transform(result.element);\n            transformed.nullable = false;\n            return transformed;\n        },\n        JsdocTypeVariadic: (result, transform) => {\n            if (result.element === undefined) {\n                throw new Error('dots without value are not allowed in catharsis mode');\n            }\n            const transformed = transform(result.element);\n            transformed.repeatable = true;\n            return transformed;\n        },\n        JsdocTypeAny: () => ({\n            type: 'AllLiteral'\n        }),\n        JsdocTypeNull: () => ({\n            type: 'NullLiteral'\n        }),\n        JsdocTypeStringValue: result => makeName(quote(result.value, result.meta.quote)),\n        JsdocTypeUndefined: () => ({\n            type: 'UndefinedLiteral'\n        }),\n        JsdocTypeUnknown: () => ({\n            type: 'UnknownLiteral'\n        }),\n        JsdocTypeFunction: (result, transform) => {\n            const params = extractSpecialParams(result);\n            const transformed = {\n                type: 'FunctionType',\n                params: params.params.map(transform)\n            };\n            if (params.this !== undefined) {\n                transformed.this = transform(params.this);\n            }\n            if (params.new !== undefined) {\n                transformed.new = transform(params.new);\n            }\n            if (result.returnType !== undefined) {\n                transformed.result = transform(result.returnType);\n            }\n            return transformed;\n        },\n        JsdocTypeGeneric: (result, transform) => ({\n            type: 'TypeApplication',\n            applications: result.elements.map(o => transform(o)),\n            expression: transform(result.left)\n        }),\n        JsdocTypeSpecialNamePath: result => makeName(result.specialType + ':' + quote(result.value, result.meta.quote)),\n        JsdocTypeName: result => {\n            if (result.value !== 'function') {\n                return makeName(result.value);\n            }\n            else {\n                return {\n                    type: 'FunctionType',\n                    params: []\n                };\n            }\n        },\n        JsdocTypeNumber: result => makeName(result.value.toString()),\n        JsdocTypeObject: (result, transform) => {\n            const transformed = {\n                type: 'RecordType',\n                fields: []\n            };\n            for (const field of result.elements) {\n                if (field.type !== 'JsdocTypeObjectField' && field.type !== 'JsdocTypeJsdocObjectField') {\n                    transformed.fields.push({\n                        type: 'FieldType',\n                        key: transform(field),\n                        value: undefined\n                    });\n                }\n                else {\n                    transformed.fields.push(transform(field));\n                }\n            }\n            return transformed;\n        },\n        JsdocTypeObjectField: (result, transform) => {\n            if (typeof result.key !== 'string') {\n                throw new Error('Index signatures and mapped types are not supported');\n            }\n            return {\n                type: 'FieldType',\n                key: makeName(quote(result.key, result.meta.quote)),\n                value: result.right === undefined ? undefined : transform(result.right)\n            };\n        },\n        JsdocTypeJsdocObjectField: (result, transform) => ({\n            type: 'FieldType',\n            key: transform(result.left),\n            value: transform(result.right)\n        }),\n        JsdocTypeUnion: (result, transform) => ({\n            type: 'TypeUnion',\n            elements: result.elements.map(e => transform(e))\n        }),\n        JsdocTypeKeyValue: (result, transform) => {\n            return {\n                type: 'FieldType',\n                key: makeName(result.key),\n                value: result.right === undefined ? undefined : transform(result.right)\n            };\n        },\n        JsdocTypeNamePath: (result, transform) => {\n            const leftResult = transform(result.left);\n            let rightValue;\n            if (result.right.type === 'JsdocTypeSpecialNamePath') {\n                rightValue = transform(result.right).name;\n            }\n            else {\n                rightValue = quote(result.right.value, result.right.meta.quote);\n            }\n            const joiner = result.pathType === 'inner' ? '~' : result.pathType === 'instance' ? '#' : '.';\n            return makeName(`${leftResult.name}${joiner}${rightValue}`);\n        },\n        JsdocTypeSymbol: result => {\n            let value = '';\n            let element = result.element;\n            let trailingDots = false;\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeVariadic') {\n                if (element.meta.position === 'prefix') {\n                    value = '...';\n                }\n                else {\n                    trailingDots = true;\n                }\n                element = element.element;\n            }\n            if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeName') {\n                value += element.value;\n            }\n            else if ((element === null || element === void 0 ? void 0 : element.type) === 'JsdocTypeNumber') {\n                value += element.value.toString();\n            }\n            if (trailingDots) {\n                value += '...';\n            }\n            return makeName(`${result.value}(${value})`);\n        },\n        JsdocTypeParenthesis: (result, transform) => transform(assertRootResult(result.element)),\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeImport: notAvailableTransform,\n        JsdocTypeKeyof: notAvailableTransform,\n        JsdocTypeTuple: notAvailableTransform,\n        JsdocTypeTypeof: notAvailableTransform,\n        JsdocTypeIntersection: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform\n    };\n    function catharsisTransform(result) {\n        return transform(catharsisTransformRules, result);\n    }\n\n    function getQuoteStyle(quote) {\n        switch (quote) {\n            case undefined:\n                return 'none';\n            case 'single':\n                return 'single';\n            case 'double':\n                return 'double';\n        }\n    }\n    function getMemberType(type) {\n        switch (type) {\n            case 'inner':\n                return 'INNER_MEMBER';\n            case 'instance':\n                return 'INSTANCE_MEMBER';\n            case 'property':\n                return 'MEMBER';\n            case 'property-brackets':\n                return 'MEMBER';\n        }\n    }\n    function nestResults(type, results) {\n        if (results.length === 2) {\n            return {\n                type,\n                left: results[0],\n                right: results[1]\n            };\n        }\n        else {\n            return {\n                type,\n                left: results[0],\n                right: nestResults(type, results.slice(1))\n            };\n        }\n    }\n    const jtpRules = {\n        JsdocTypeOptional: (result, transform) => ({\n            type: 'OPTIONAL',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_EQUAL_SIGN' : 'SUFFIX_EQUALS_SIGN'\n            }\n        }),\n        JsdocTypeNullable: (result, transform) => ({\n            type: 'NULLABLE',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_QUESTION_MARK' : 'SUFFIX_QUESTION_MARK'\n            }\n        }),\n        JsdocTypeNotNullable: (result, transform) => ({\n            type: 'NOT_NULLABLE',\n            value: transform(result.element),\n            meta: {\n                syntax: result.meta.position === 'prefix' ? 'PREFIX_BANG' : 'SUFFIX_BANG'\n            }\n        }),\n        JsdocTypeVariadic: (result, transform) => {\n            const transformed = {\n                type: 'VARIADIC',\n                meta: {\n                    syntax: result.meta.position === 'prefix'\n                        ? 'PREFIX_DOTS'\n                        : result.meta.position === 'suffix' ? 'SUFFIX_DOTS' : 'ONLY_DOTS'\n                }\n            };\n            if (result.element !== undefined) {\n                transformed.value = transform(result.element);\n            }\n            return transformed;\n        },\n        JsdocTypeName: result => ({\n            type: 'NAME',\n            name: result.value\n        }),\n        JsdocTypeTypeof: (result, transform) => ({\n            type: 'TYPE_QUERY',\n            name: transform(result.element)\n        }),\n        JsdocTypeTuple: (result, transform) => ({\n            type: 'TUPLE',\n            entries: result.elements.map(transform)\n        }),\n        JsdocTypeKeyof: (result, transform) => ({\n            type: 'KEY_QUERY',\n            value: transform(result.element)\n        }),\n        JsdocTypeImport: result => ({\n            type: 'IMPORT',\n            path: {\n                type: 'STRING_VALUE',\n                quoteStyle: getQuoteStyle(result.element.meta.quote),\n                string: result.element.value\n            }\n        }),\n        JsdocTypeUndefined: () => ({\n            type: 'NAME',\n            name: 'undefined'\n        }),\n        JsdocTypeAny: () => ({\n            type: 'ANY'\n        }),\n        JsdocTypeFunction: (result, transform) => {\n            const specialParams = extractSpecialParams(result);\n            const transformed = {\n                type: result.arrow ? 'ARROW' : 'FUNCTION',\n                params: specialParams.params.map(param => {\n                    if (param.type === 'JsdocTypeKeyValue') {\n                        if (param.right === undefined) {\n                            throw new Error('Function parameter without \\':\\' is not expected to be \\'KEY_VALUE\\'');\n                        }\n                        return {\n                            type: 'NAMED_PARAMETER',\n                            name: param.key,\n                            typeName: transform(param.right)\n                        };\n                    }\n                    else {\n                        return transform(param);\n                    }\n                }),\n                new: null,\n                returns: null\n            };\n            if (specialParams.this !== undefined) {\n                transformed.this = transform(specialParams.this);\n            }\n            else if (!result.arrow) {\n                transformed.this = null;\n            }\n            if (specialParams.new !== undefined) {\n                transformed.new = transform(specialParams.new);\n            }\n            if (result.returnType !== undefined) {\n                transformed.returns = transform(result.returnType);\n            }\n            return transformed;\n        },\n        JsdocTypeGeneric: (result, transform) => {\n            const transformed = {\n                type: 'GENERIC',\n                subject: transform(result.left),\n                objects: result.elements.map(transform),\n                meta: {\n                    syntax: result.meta.brackets === 'square' ? 'SQUARE_BRACKET' : result.meta.dot ? 'ANGLE_BRACKET_WITH_DOT' : 'ANGLE_BRACKET'\n                }\n            };\n            if (result.meta.brackets === 'square' && result.elements[0].type === 'JsdocTypeFunction' && !result.elements[0].parenthesis) {\n                transformed.objects[0] = {\n                    type: 'NAME',\n                    name: 'function'\n                };\n            }\n            return transformed;\n        },\n        JsdocTypeObjectField: (result, transform) => {\n            if (typeof result.key !== 'string') {\n                throw new Error('Index signatures and mapped types are not supported');\n            }\n            if (result.right === undefined) {\n                return {\n                    type: 'RECORD_ENTRY',\n                    key: result.key,\n                    quoteStyle: getQuoteStyle(result.meta.quote),\n                    value: null,\n                    readonly: false\n                };\n            }\n            let right = transform(result.right);\n            if (result.optional) {\n                right = {\n                    type: 'OPTIONAL',\n                    value: right,\n                    meta: {\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\n                    }\n                };\n            }\n            return {\n                type: 'RECORD_ENTRY',\n                key: result.key.toString(),\n                quoteStyle: getQuoteStyle(result.meta.quote),\n                value: right,\n                readonly: false\n            };\n        },\n        JsdocTypeJsdocObjectField: () => {\n            throw new Error('Keys may not be typed in jsdoctypeparser.');\n        },\n        JsdocTypeKeyValue: (result, transform) => {\n            if (result.right === undefined) {\n                return {\n                    type: 'RECORD_ENTRY',\n                    key: result.key,\n                    quoteStyle: 'none',\n                    value: null,\n                    readonly: false\n                };\n            }\n            let right = transform(result.right);\n            if (result.optional) {\n                right = {\n                    type: 'OPTIONAL',\n                    value: right,\n                    meta: {\n                        syntax: 'SUFFIX_KEY_QUESTION_MARK'\n                    }\n                };\n            }\n            return {\n                type: 'RECORD_ENTRY',\n                key: result.key,\n                quoteStyle: 'none',\n                value: right,\n                readonly: false\n            };\n        },\n        JsdocTypeObject: (result, transform) => {\n            const entries = [];\n            for (const field of result.elements) {\n                if (field.type === 'JsdocTypeObjectField' || field.type === 'JsdocTypeJsdocObjectField') {\n                    entries.push(transform(field));\n                }\n            }\n            return {\n                type: 'RECORD',\n                entries\n            };\n        },\n        JsdocTypeSpecialNamePath: result => {\n            if (result.specialType !== 'module') {\n                throw new Error(`jsdoctypeparser does not support type ${result.specialType} at this point.`);\n            }\n            return {\n                type: 'MODULE',\n                value: {\n                    type: 'FILE_PATH',\n                    quoteStyle: getQuoteStyle(result.meta.quote),\n                    path: result.value\n                }\n            };\n        },\n        JsdocTypeNamePath: (result, transform) => {\n            let hasEventPrefix = false;\n            let name;\n            let quoteStyle;\n            if (result.right.type === 'JsdocTypeSpecialNamePath' && result.right.specialType === 'event') {\n                hasEventPrefix = true;\n                name = result.right.value;\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\n            }\n            else {\n                name = result.right.value;\n                quoteStyle = getQuoteStyle(result.right.meta.quote);\n            }\n            const transformed = {\n                type: getMemberType(result.pathType),\n                owner: transform(result.left),\n                name,\n                quoteStyle,\n                hasEventPrefix\n            };\n            if (transformed.owner.type === 'MODULE') {\n                const tModule = transformed.owner;\n                transformed.owner = transformed.owner.value;\n                tModule.value = transformed;\n                return tModule;\n            }\n            else {\n                return transformed;\n            }\n        },\n        JsdocTypeUnion: (result, transform) => nestResults('UNION', result.elements.map(transform)),\n        JsdocTypeParenthesis: (result, transform) => ({\n            type: 'PARENTHESIS',\n            value: transform(assertRootResult(result.element))\n        }),\n        JsdocTypeNull: () => ({\n            type: 'NAME',\n            name: 'null'\n        }),\n        JsdocTypeUnknown: () => ({\n            type: 'UNKNOWN'\n        }),\n        JsdocTypeStringValue: result => ({\n            type: 'STRING_VALUE',\n            quoteStyle: getQuoteStyle(result.meta.quote),\n            string: result.value\n        }),\n        JsdocTypeIntersection: (result, transform) => nestResults('INTERSECTION', result.elements.map(transform)),\n        JsdocTypeNumber: result => ({\n            type: 'NUMBER_VALUE',\n            number: result.value.toString()\n        }),\n        JsdocTypeSymbol: notAvailableTransform,\n        JsdocTypeProperty: notAvailableTransform,\n        JsdocTypePredicate: notAvailableTransform,\n        JsdocTypeMappedType: notAvailableTransform,\n        JsdocTypeIndexSignature: notAvailableTransform,\n        JsdocTypeAsserts: notAvailableTransform\n    };\n    function jtpTransform(result) {\n        return transform(jtpRules, result);\n    }\n\n    function identityTransformRules() {\n        return {\n            JsdocTypeIntersection: (result, transform) => ({\n                type: 'JsdocTypeIntersection',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeGeneric: (result, transform) => ({\n                type: 'JsdocTypeGeneric',\n                left: transform(result.left),\n                elements: result.elements.map(transform),\n                meta: {\n                    dot: result.meta.dot,\n                    brackets: result.meta.brackets\n                }\n            }),\n            JsdocTypeNullable: result => result,\n            JsdocTypeUnion: (result, transform) => ({\n                type: 'JsdocTypeUnion',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeUnknown: result => result,\n            JsdocTypeUndefined: result => result,\n            JsdocTypeTypeof: (result, transform) => ({\n                type: 'JsdocTypeTypeof',\n                element: transform(result.element)\n            }),\n            JsdocTypeSymbol: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeSymbol',\n                    value: result.value\n                };\n                if (result.element !== undefined) {\n                    transformed.element = transform(result.element);\n                }\n                return transformed;\n            },\n            JsdocTypeOptional: (result, transform) => ({\n                type: 'JsdocTypeOptional',\n                element: transform(result.element),\n                meta: {\n                    position: result.meta.position\n                }\n            }),\n            JsdocTypeObject: (result, transform) => ({\n                type: 'JsdocTypeObject',\n                meta: {\n                    separator: 'comma'\n                },\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeNumber: result => result,\n            JsdocTypeNull: result => result,\n            JsdocTypeNotNullable: (result, transform) => ({\n                type: 'JsdocTypeNotNullable',\n                element: transform(result.element),\n                meta: {\n                    position: result.meta.position\n                }\n            }),\n            JsdocTypeSpecialNamePath: result => result,\n            JsdocTypeObjectField: (result, transform) => ({\n                type: 'JsdocTypeObjectField',\n                key: result.key,\n                right: result.right === undefined ? undefined : transform(result.right),\n                optional: result.optional,\n                readonly: result.readonly,\n                meta: result.meta\n            }),\n            JsdocTypeJsdocObjectField: (result, transform) => ({\n                type: 'JsdocTypeJsdocObjectField',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeKeyValue: (result, transform) => {\n                return {\n                    type: 'JsdocTypeKeyValue',\n                    key: result.key,\n                    right: result.right === undefined ? undefined : transform(result.right),\n                    optional: result.optional,\n                    variadic: result.variadic\n                };\n            },\n            JsdocTypeImport: (result, transform) => ({\n                type: 'JsdocTypeImport',\n                element: transform(result.element)\n            }),\n            JsdocTypeAny: result => result,\n            JsdocTypeStringValue: result => result,\n            JsdocTypeNamePath: result => result,\n            JsdocTypeVariadic: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeVariadic',\n                    meta: {\n                        position: result.meta.position,\n                        squareBrackets: result.meta.squareBrackets\n                    }\n                };\n                if (result.element !== undefined) {\n                    transformed.element = transform(result.element);\n                }\n                return transformed;\n            },\n            JsdocTypeTuple: (result, transform) => ({\n                type: 'JsdocTypeTuple',\n                elements: result.elements.map(transform)\n            }),\n            JsdocTypeName: result => result,\n            JsdocTypeFunction: (result, transform) => {\n                const transformed = {\n                    type: 'JsdocTypeFunction',\n                    arrow: result.arrow,\n                    parameters: result.parameters.map(transform),\n                    constructor: result.constructor,\n                    parenthesis: result.parenthesis\n                };\n                if (result.returnType !== undefined) {\n                    transformed.returnType = transform(result.returnType);\n                }\n                return transformed;\n            },\n            JsdocTypeKeyof: (result, transform) => ({\n                type: 'JsdocTypeKeyof',\n                element: transform(result.element)\n            }),\n            JsdocTypeParenthesis: (result, transform) => ({\n                type: 'JsdocTypeParenthesis',\n                element: transform(result.element)\n            }),\n            JsdocTypeProperty: result => result,\n            JsdocTypePredicate: (result, transform) => ({\n                type: 'JsdocTypePredicate',\n                left: transform(result.left),\n                right: transform(result.right)\n            }),\n            JsdocTypeIndexSignature: (result, transform) => ({\n                type: 'JsdocTypeIndexSignature',\n                key: result.key,\n                right: transform(result.right)\n            }),\n            JsdocTypeMappedType: (result, transform) => ({\n                type: 'JsdocTypeMappedType',\n                key: result.key,\n                right: transform(result.right)\n            }),\n            JsdocTypeAsserts: (result, transform) => ({\n                type: 'JsdocTypeAsserts',\n                left: transform(result.left),\n                right: transform(result.right)\n            })\n        };\n    }\n\n    const visitorKeys = {\n        JsdocTypeAny: [],\n        JsdocTypeFunction: ['parameters', 'returnType'],\n        JsdocTypeGeneric: ['left', 'elements'],\n        JsdocTypeImport: [],\n        JsdocTypeIndexSignature: ['right'],\n        JsdocTypeIntersection: ['elements'],\n        JsdocTypeKeyof: ['element'],\n        JsdocTypeKeyValue: ['right'],\n        JsdocTypeMappedType: ['right'],\n        JsdocTypeName: [],\n        JsdocTypeNamePath: ['left', 'right'],\n        JsdocTypeNotNullable: ['element'],\n        JsdocTypeNull: [],\n        JsdocTypeNullable: ['element'],\n        JsdocTypeNumber: [],\n        JsdocTypeObject: ['elements'],\n        JsdocTypeObjectField: ['right'],\n        JsdocTypeJsdocObjectField: ['left', 'right'],\n        JsdocTypeOptional: ['element'],\n        JsdocTypeParenthesis: ['element'],\n        JsdocTypeSpecialNamePath: [],\n        JsdocTypeStringValue: [],\n        JsdocTypeSymbol: ['element'],\n        JsdocTypeTuple: ['elements'],\n        JsdocTypeTypeof: ['element'],\n        JsdocTypeUndefined: [],\n        JsdocTypeUnion: ['elements'],\n        JsdocTypeUnknown: [],\n        JsdocTypeVariadic: ['element'],\n        JsdocTypeProperty: [],\n        JsdocTypePredicate: ['left', 'right'],\n        JsdocTypeAsserts: ['left', 'right']\n    };\n\n    function _traverse(node, parentNode, property, onEnter, onLeave) {\n        onEnter === null || onEnter === void 0 ? void 0 : onEnter(node, parentNode, property);\n        const keysToVisit = visitorKeys[node.type];\n        for (const key of keysToVisit) {\n            const value = node[key];\n            if (value !== undefined) {\n                if (Array.isArray(value)) {\n                    for (const element of value) {\n                        _traverse(element, node, key, onEnter, onLeave);\n                    }\n                }\n                else {\n                    _traverse(value, node, key, onEnter, onLeave);\n                }\n            }\n        }\n        onLeave === null || onLeave === void 0 ? void 0 : onLeave(node, parentNode, property);\n    }\n    /**\n     * A function to traverse an AST. It traverses it depth first.\n     * @param node the node to start traversing at.\n     * @param onEnter node visitor function that will be called on entering the node. This corresponds to preorder traversing.\n     * @param onLeave node visitor function that will be called on leaving the node. This corresponds to postorder traversing.\n     */\n    function traverse(node, onEnter, onLeave) {\n        _traverse(node, undefined, undefined, onEnter, onLeave);\n    }\n\n    exports.catharsisTransform = catharsisTransform;\n    exports.identityTransformRules = identityTransformRules;\n    exports.jtpTransform = jtpTransform;\n    exports.parse = parse;\n    exports.stringify = stringify;\n    exports.stringifyRules = stringifyRules;\n    exports.transform = transform;\n    exports.traverse = traverse;\n    exports.tryParse = tryParse;\n    exports.visitorKeys = visitorKeys;\n\n}));\n","var De = Object.defineProperty;\nvar o = (e, t) => De(e, \"name\", { value: t, configurable: !0 });\n\n// src/docs-tools/argTypes/convert/flow/convert.ts\nimport { UnknownArgTypesError as Te } from \"@storybook/core/preview-errors\";\nvar he = /* @__PURE__ */ o((e) => e.name === \"literal\", \"isLiteral\"), be = /* @__PURE__ */ o((e) => e.value.replace(/['|\"]/g, \"\"), \"toEnumOp\\\ntion\"), Pe = /* @__PURE__ */ o((e) => {\n  switch (e.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let t = {};\n      return e.signature.properties.forEach((r) => {\n        t[r.key] = d(r.value);\n      }), {\n        name: \"object\",\n        value: t\n      };\n    default:\n      throw new Te({ type: e, language: \"Flow\" });\n  }\n}, \"convertSig\"), d = /* @__PURE__ */ o((e) => {\n  let { name: t, raw: r } = e, n = {};\n  switch (typeof r < \"u\" && (n.raw = r), e.name) {\n    case \"literal\":\n      return { ...n, name: \"other\", value: e.value };\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...n, name: t };\n    case \"Array\":\n      return { ...n, name: \"array\", value: e.elements.map(d) };\n    case \"signature\":\n      return { ...n, ...Pe(e) };\n    case \"union\":\n      return e.elements?.every(he) ? { ...n, name: \"enum\", value: e.elements?.map(be) } : { ...n, name: t, value: e.elements?.map(d) };\n    case \"intersection\":\n      return { ...n, name: t, value: e.elements?.map(d) };\n    default:\n      return { ...n, name: \"other\", value: t };\n  }\n}, \"convert\");\n\n// ../node_modules/es-toolkit/dist/object/mapValues.mjs\nfunction j(e, t) {\n  let r = {}, n = Object.keys(e);\n  for (let s = 0; s < n.length; s++) {\n    let i = n[s], p = e[i];\n    r[i] = t(p, i, e);\n  }\n  return r;\n}\no(j, \"mapValues\");\n\n// src/docs-tools/argTypes/convert/utils.ts\nvar W = /^['\"]|['\"]$/g, Se = /* @__PURE__ */ o((e) => e.replace(W, \"\"), \"trimQuotes\"), Oe = /* @__PURE__ */ o((e) => W.test(e), \"includesQuo\\\ntes\"), h = /* @__PURE__ */ o((e) => {\n  let t = Se(e);\n  return Oe(e) || Number.isNaN(Number(t)) ? t : Number(t);\n}, \"parseLiteral\");\n\n// src/docs-tools/argTypes/convert/proptypes/convert.ts\nvar ve = /^\\(.*\\) => /, x = /* @__PURE__ */ o((e) => {\n  let { name: t, raw: r, computed: n, value: s } = e, i = {};\n  switch (typeof r < \"u\" && (i.raw = r), t) {\n    case \"enum\": {\n      let a = n ? s : s.map((c) => h(c.value));\n      return { ...i, name: t, value: a };\n    }\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n      return { ...i, name: t };\n    case \"func\":\n      return { ...i, name: \"function\" };\n    case \"bool\":\n    case \"boolean\":\n      return { ...i, name: \"boolean\" };\n    case \"arrayOf\":\n    case \"array\":\n      return { ...i, name: \"array\", value: s && x(s) };\n    case \"object\":\n      return { ...i, name: t };\n    case \"objectOf\":\n      return { ...i, name: t, value: x(s) };\n    case \"shape\":\n    case \"exact\":\n      let p = j(s, (a) => x(a));\n      return { ...i, name: \"object\", value: p };\n    case \"union\":\n      return { ...i, name: \"union\", value: s.map((a) => x(a)) };\n    case \"instanceOf\":\n    case \"element\":\n    case \"elementType\":\n    default: {\n      if (t?.indexOf(\"|\") > 0)\n        try {\n          let u = t.split(\"|\").map((m) => JSON.parse(m));\n          return { ...i, name: \"enum\", value: u };\n        } catch {\n        }\n      let a = s ? `${t}(${s})` : t, c = ve.test(t) ? \"function\" : \"other\";\n      return { ...i, name: c, value: a };\n    }\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/typescript/convert.ts\nimport { UnknownArgTypesError as we } from \"@storybook/core/preview-errors\";\nvar Ee = /* @__PURE__ */ o((e) => {\n  switch (e.type) {\n    case \"function\":\n      return { name: \"function\" };\n    case \"object\":\n      let t = {};\n      return e.signature.properties.forEach((r) => {\n        t[r.key] = D(r.value);\n      }), {\n        name: \"object\",\n        value: t\n      };\n    default:\n      throw new we({ type: e, language: \"Typescript\" });\n  }\n}, \"convertSig\"), D = /* @__PURE__ */ o((e) => {\n  let { name: t, raw: r } = e, n = {};\n  switch (typeof r < \"u\" && (n.raw = r), e.name) {\n    case \"string\":\n    case \"number\":\n    case \"symbol\":\n    case \"boolean\":\n      return { ...n, name: t };\n    case \"Array\":\n      return { ...n, name: \"array\", value: e.elements.map(D) };\n    case \"signature\":\n      return { ...n, ...Ee(e) };\n    case \"union\":\n      let s;\n      return e.elements?.every((i) => i.name === \"literal\") ? s = {\n        ...n,\n        name: \"enum\",\n        // @ts-expect-error fix types\n        value: e.elements?.map((i) => h(i.value))\n      } : s = { ...n, name: t, value: e.elements?.map(D) }, s;\n    case \"intersection\":\n      return { ...n, name: t, value: e.elements?.map(D) };\n    default:\n      return { ...n, name: \"other\", value: t };\n  }\n}, \"convert\");\n\n// src/docs-tools/argTypes/convert/index.ts\nvar b = /* @__PURE__ */ o((e) => {\n  let { type: t, tsType: r, flowType: n } = e;\n  try {\n    if (t != null)\n      return x(t);\n    if (r != null)\n      return D(r);\n    if (n != null)\n      return d(n);\n  } catch (s) {\n    console.error(s);\n  }\n  return null;\n}, \"convert\");\n\n// src/docs-tools/argTypes/docgen/types.ts\nvar je = /* @__PURE__ */ ((s) => (s.JAVASCRIPT = \"JavaScript\", s.FLOW = \"Flow\", s.TYPESCRIPT = \"TypeScript\", s.UNKNOWN = \"Unknown\", s))(je ||\n{});\n\n// src/docs-tools/argTypes/docgen/utils/defaultValue.ts\nvar ke = [\"null\", \"undefined\"];\nfunction T(e) {\n  return ke.some((t) => t === e);\n}\no(T, \"isDefaultValueBlacklisted\");\n\n// src/docs-tools/argTypes/docgen/utils/string.ts\nvar M = /* @__PURE__ */ o((e) => {\n  if (!e)\n    return \"\";\n  if (typeof e == \"string\")\n    return e;\n  throw new Error(`Description: expected string, got: ${JSON.stringify(e)}`);\n}, \"str\");\n\n// src/docs-tools/argTypes/docgen/utils/docgenInfo.ts\nfunction z(e) {\n  return !!e.__docgenInfo;\n}\no(z, \"hasDocgen\");\nfunction $(e) {\n  return e != null && Object.keys(e).length > 0;\n}\no($, \"isValidDocgenSection\");\nfunction Y(e, t) {\n  return z(e) ? e.__docgenInfo[t] : null;\n}\no(Y, \"getDocgenSection\");\nfunction q(e) {\n  return z(e) ? M(e.__docgenInfo.description) : \"\";\n}\no(q, \"getDocgenDescription\");\n\n// ../node_modules/comment-parser/es6/primitives.js\nvar f;\n(function(e) {\n  e.start = \"/**\", e.nostart = \"/***\", e.delim = \"*\", e.end = \"*/\";\n})(f = f || (f = {}));\n\n// ../node_modules/comment-parser/es6/util.js\nfunction k(e) {\n  return /^\\s+$/.test(e);\n}\no(k, \"isSpace\");\nfunction G(e) {\n  let t = e.match(/\\r+$/);\n  return t == null ? [\"\", e] : [e.slice(-t[0].length), e.slice(0, -t[0].length)];\n}\no(G, \"splitCR\");\nfunction y(e) {\n  let t = e.match(/^\\s+/);\n  return t == null ? [\"\", e] : [e.slice(0, t[0].length), e.slice(t[0].length)];\n}\no(y, \"splitSpace\");\nfunction K(e) {\n  return e.split(/\\n/);\n}\no(K, \"splitLines\");\nfunction X(e = {}) {\n  return Object.assign({ tag: \"\", name: \"\", type: \"\", optional: !1, description: \"\", problems: [], source: [] }, e);\n}\no(X, \"seedSpec\");\nfunction F(e = {}) {\n  return Object.assign({ start: \"\", delimiter: \"\", postDelimiter: \"\", tag: \"\", postTag: \"\", name: \"\", postName: \"\", type: \"\", postType: \"\", description: \"\",\n  end: \"\", lineEnd: \"\" }, e);\n}\no(F, \"seedTokens\");\n\n// ../node_modules/comment-parser/es6/parser/block-parser.js\nvar Fe = /^@\\S+/;\nfunction J({ fence: e = \"```\" } = {}) {\n  let t = Je(e), r = /* @__PURE__ */ o((n, s) => t(n) ? !s : s, \"toggleFence\");\n  return /* @__PURE__ */ o(function(s) {\n    let i = [[]], p = !1;\n    for (let a of s)\n      Fe.test(a.tokens.description) && !p ? i.push([a]) : i[i.length - 1].push(a), p = r(a.tokens.description, p);\n    return i;\n  }, \"parseBlock\");\n}\no(J, \"getParser\");\nfunction Je(e) {\n  return typeof e == \"string\" ? (t) => t.split(e).length % 2 === 0 : e;\n}\no(Je, \"getFencer\");\n\n// ../node_modules/comment-parser/es6/parser/source-parser.js\nfunction N({ startLine: e = 0, markers: t = f } = {}) {\n  let r = null, n = e;\n  return /* @__PURE__ */ o(function(i) {\n    let p = i, a = F();\n    if ([a.lineEnd, p] = G(p), [a.start, p] = y(p), r === null && p.startsWith(t.start) && !p.startsWith(t.nostart) && (r = [], a.delimiter =\n    p.slice(0, t.start.length), p = p.slice(t.start.length), [a.postDelimiter, p] = y(p)), r === null)\n      return n++, null;\n    let c = p.trimRight().endsWith(t.end);\n    if (a.delimiter === \"\" && p.startsWith(t.delim) && !p.startsWith(t.end) && (a.delimiter = t.delim, p = p.slice(t.delim.length), [a.postDelimiter,\n    p] = y(p)), c) {\n      let u = p.trimRight();\n      a.end = p.slice(u.length - t.end.length), p = u.slice(0, -t.end.length);\n    }\n    if (a.description = p, r.push({ number: n, source: i, tokens: a }), n++, c) {\n      let u = r.slice();\n      return r = null, u;\n    }\n    return null;\n  }, \"parseSource\");\n}\no(N, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/spec-parser.js\nfunction R({ tokenizers: e }) {\n  return /* @__PURE__ */ o(function(r) {\n    var n;\n    let s = X({ source: r });\n    for (let i of e)\n      if (s = i(s), !((n = s.problems[s.problems.length - 1]) === null || n === void 0) && n.critical)\n        break;\n    return s;\n  }, \"parseSpec\");\n}\no(R, \"getParser\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/tag.js\nfunction P() {\n  return (e) => {\n    let { tokens: t } = e.source[0], r = t.description.match(/\\s*(@(\\S+))(\\s*)/);\n    return r === null ? (e.problems.push({\n      code: \"spec:tag:prefix\",\n      message: 'tag should start with \"@\" symbol',\n      line: e.source[0].number,\n      critical: !0\n    }), e) : (t.tag = r[1], t.postTag = r[3], t.description = t.description.slice(r[0].length), e.tag = r[2], e);\n  };\n}\no(P, \"tagTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/type.js\nfunction S(e = \"compact\") {\n  let t = Re(e);\n  return (r) => {\n    let n = 0, s = [];\n    for (let [a, { tokens: c }] of r.source.entries()) {\n      let u = \"\";\n      if (a === 0 && c.description[0] !== \"{\")\n        return r;\n      for (let m of c.description)\n        if (m === \"{\" && n++, m === \"}\" && n--, u += m, n === 0)\n          break;\n      if (s.push([c, u]), n === 0)\n        break;\n    }\n    if (n !== 0)\n      return r.problems.push({\n        code: \"spec:type:unpaired-curlies\",\n        message: \"unpaired curlies\",\n        line: r.source[0].number,\n        critical: !0\n      }), r;\n    let i = [], p = s[0][0].postDelimiter.length;\n    for (let [a, [c, u]] of s.entries())\n      c.type = u, a > 0 && (c.type = c.postDelimiter.slice(p) + u, c.postDelimiter = c.postDelimiter.slice(0, p)), [c.postType, c.description] =\n      y(c.description.slice(u.length)), i.push(c.type);\n    return i[0] = i[0].slice(1), i[i.length - 1] = i[i.length - 1].slice(0, -1), r.type = t(i), r;\n  };\n}\no(S, \"typeTokenizer\");\nvar Ne = /* @__PURE__ */ o((e) => e.trim(), \"trim\");\nfunction Re(e) {\n  return e === \"compact\" ? (t) => t.map(Ne).join(\"\") : e === \"preserve\" ? (t) => t.join(`\n`) : e;\n}\no(Re, \"getJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/name.js\nvar Ae = /* @__PURE__ */ o((e) => e && e.startsWith('\"') && e.endsWith('\"'), \"isQuoted\");\nfunction O() {\n  let e = /* @__PURE__ */ o((t, { tokens: r }, n) => r.type === \"\" ? t : n, \"typeEnd\");\n  return (t) => {\n    let { tokens: r } = t.source[t.source.reduce(e, 0)], n = r.description.trimLeft(), s = n.split('\"');\n    if (s.length > 1 && s[0] === \"\" && s.length % 2 === 1)\n      return t.name = s[1], r.name = `\"${s[1]}\"`, [r.postName, r.description] = y(n.slice(r.name.length)), t;\n    let i = 0, p = \"\", a = !1, c;\n    for (let m of n) {\n      if (i === 0 && k(m))\n        break;\n      m === \"[\" && i++, m === \"]\" && i--, p += m;\n    }\n    if (i !== 0)\n      return t.problems.push({\n        code: \"spec:name:unpaired-brackets\",\n        message: \"unpaired brackets\",\n        line: t.source[0].number,\n        critical: !0\n      }), t;\n    let u = p;\n    if (p[0] === \"[\" && p[p.length - 1] === \"]\") {\n      a = !0, p = p.slice(1, -1);\n      let m = p.split(\"=\");\n      if (p = m[0].trim(), m[1] !== void 0 && (c = m.slice(1).join(\"=\").trim()), p === \"\")\n        return t.problems.push({\n          code: \"spec:name:empty-name\",\n          message: \"empty name\",\n          line: t.source[0].number,\n          critical: !0\n        }), t;\n      if (c === \"\")\n        return t.problems.push({\n          code: \"spec:name:empty-default\",\n          message: \"empty default value\",\n          line: t.source[0].number,\n          critical: !0\n        }), t;\n      if (!Ae(c) && /=(?!>)/.test(c))\n        return t.problems.push({\n          code: \"spec:name:invalid-default\",\n          message: \"invalid default value syntax\",\n          line: t.source[0].number,\n          critical: !0\n        }), t;\n    }\n    return t.optional = a, t.name = p, r.name = u, c !== void 0 && (t.default = c), [r.postName, r.description] = y(n.slice(r.name.length)),\n    t;\n  };\n}\no(O, \"nameTokenizer\");\n\n// ../node_modules/comment-parser/es6/parser/tokenizers/description.js\nfunction v(e = \"compact\", t = f) {\n  let r = A(e);\n  return (n) => (n.description = r(n.source, t), n);\n}\no(v, \"descriptionTokenizer\");\nfunction A(e) {\n  return e === \"compact\" ? Ve : e === \"preserve\" ? Be : e;\n}\no(A, \"getJoiner\");\nfunction Ve(e, t = f) {\n  return e.map(({ tokens: { description: r } }) => r.trim()).filter((r) => r !== \"\").join(\" \");\n}\no(Ve, \"compactJoiner\");\nvar Ce = /* @__PURE__ */ o((e, { tokens: t }, r) => t.type === \"\" ? e : r, \"lineNo\"), _e = /* @__PURE__ */ o(({ tokens: e }) => (e.delimiter ===\n\"\" ? e.start : e.postDelimiter.slice(1)) + e.description, \"getDescription\");\nfunction Be(e, t = f) {\n  if (e.length === 0)\n    return \"\";\n  e[0].tokens.description === \"\" && e[0].tokens.delimiter === t.start && (e = e.slice(1));\n  let r = e[e.length - 1];\n  return r !== void 0 && r.tokens.description === \"\" && r.tokens.end.endsWith(t.end) && (e = e.slice(0, -1)), e = e.slice(e.reduce(Ce, 0)), e.\n  map(_e).join(`\n`);\n}\no(Be, \"preserveJoiner\");\n\n// ../node_modules/comment-parser/es6/parser/index.js\nfunction V({ startLine: e = 0, fence: t = \"```\", spacing: r = \"compact\", markers: n = f, tokenizers: s = [\n  P(),\n  S(r),\n  O(),\n  v(r)\n] } = {}) {\n  if (e < 0 || e % 1 > 0)\n    throw new Error(\"Invalid startLine\");\n  let i = N({ startLine: e, markers: n }), p = J({ fence: t }), a = R({ tokenizers: s }), c = A(r);\n  return function(u) {\n    let m = [];\n    for (let ge of K(u)) {\n      let E = i(ge);\n      if (E === null)\n        continue;\n      let L = p(E), U = L.slice(1).map(a);\n      m.push({\n        description: c(L[0], n),\n        tags: U,\n        source: E,\n        problems: U.reduce((de, xe) => de.concat(xe.problems), [])\n      });\n    }\n    return m;\n  };\n}\no(V, \"getParser\");\n\n// ../node_modules/comment-parser/es6/stringifier/index.js\nfunction Ie(e) {\n  return e.start + e.delimiter + e.postDelimiter + e.tag + e.postTag + e.type + e.postType + e.name + e.postName + e.description + e.end + e.\n  lineEnd;\n}\no(Ie, \"join\");\nfunction C() {\n  return (e) => e.source.map(({ tokens: t }) => Ie(t)).join(`\n`);\n}\no(C, \"getStringifier\");\n\n// ../node_modules/comment-parser/es6/stringifier/inspect.js\nvar Le = {\n  line: 0,\n  start: 0,\n  delimiter: 0,\n  postDelimiter: 0,\n  tag: 0,\n  postTag: 0,\n  name: 0,\n  postName: 0,\n  type: 0,\n  postType: 0,\n  description: 0,\n  end: 0,\n  lineEnd: 0\n};\nvar Mr = Object.keys(Le);\n\n// ../node_modules/comment-parser/es6/index.js\nfunction H(e, t = {}) {\n  return V(t)(e);\n}\no(H, \"parse\");\nvar lo = C();\n\n// src/docs-tools/argTypes/jsdocParser.ts\nimport {\n  parse as Ue,\n  stringifyRules as We,\n  transform as Me\n} from \"jsdoc-type-pratt-parser\";\nfunction ze(e) {\n  return e != null && e.includes(\"@\");\n}\no(ze, \"containsJsDoc\");\nfunction $e(e) {\n  let n = `/**\n` + (e ?? \"\").split(`\n`).map((i) => ` * ${i}`).join(`\n`) + `\n*/`, s = H(n, {\n    spacing: \"preserve\"\n  });\n  if (!s || s.length === 0)\n    throw new Error(\"Cannot parse JSDoc tags.\");\n  return s[0];\n}\no($e, \"parse\");\nvar Ye = {\n  tags: [\"param\", \"arg\", \"argument\", \"returns\", \"ignore\", \"deprecated\"]\n}, Q = /* @__PURE__ */ o((e, t = Ye) => {\n  if (!ze(e))\n    return {\n      includesJsDoc: !1,\n      ignore: !1\n    };\n  let r = $e(e), n = qe(r, t.tags);\n  return n.ignore ? {\n    includesJsDoc: !0,\n    ignore: !0\n  } : {\n    includesJsDoc: !0,\n    ignore: !1,\n    // Always use the parsed description to ensure JSDoc is removed from the description.\n    description: r.description.trim(),\n    extractedTags: n\n  };\n}, \"parseJsDoc\");\nfunction qe(e, t) {\n  let r = {\n    params: null,\n    deprecated: null,\n    returns: null,\n    ignore: !1\n  };\n  for (let n of e.tags)\n    if (!(t !== void 0 && !t.includes(n.tag)))\n      if (n.tag === \"ignore\") {\n        r.ignore = !0;\n        break;\n      } else\n        switch (n.tag) {\n          // arg & argument are aliases for param.\n          case \"param\":\n          case \"arg\":\n          case \"argument\": {\n            let s = Ke(n);\n            s != null && (r.params == null && (r.params = []), r.params.push(s));\n            break;\n          }\n          case \"deprecated\": {\n            let s = Xe(n);\n            s != null && (r.deprecated = s);\n            break;\n          }\n          case \"returns\": {\n            let s = He(n);\n            s != null && (r.returns = s);\n            break;\n          }\n          default:\n            break;\n        }\n  return r;\n}\no(qe, \"extractJsDocTags\");\nfunction Ge(e) {\n  return e.replace(/[\\.-]$/, \"\");\n}\no(Ge, \"normaliseParamName\");\nfunction Ke(e) {\n  if (!e.name || e.name === \"-\")\n    return null;\n  let t = te(e.type);\n  return {\n    name: e.name,\n    type: t,\n    description: ee(e.description),\n    getPrettyName: /* @__PURE__ */ o(() => Ge(e.name), \"getPrettyName\"),\n    getTypeName: /* @__PURE__ */ o(() => t ? re(t) : null, \"getTypeName\")\n  };\n}\no(Ke, \"extractParam\");\nfunction Xe(e) {\n  return e.name ? Z(e.name, e.description) : null;\n}\no(Xe, \"extractDeprecated\");\nfunction Z(e, t) {\n  let r = e === \"\" ? t : `${e} ${t}`;\n  return ee(r);\n}\no(Z, \"joinNameAndDescription\");\nfunction ee(e) {\n  let t = e.replace(/^- /g, \"\").trim();\n  return t === \"\" ? null : t;\n}\no(ee, \"normaliseDescription\");\nfunction He(e) {\n  let t = te(e.type);\n  return t ? {\n    type: t,\n    description: Z(e.name, e.description),\n    getTypeName: /* @__PURE__ */ o(() => re(t), \"getTypeName\")\n  } : null;\n}\no(He, \"extractReturns\");\nvar g = We(), Qe = g.JsdocTypeObject;\ng.JsdocTypeAny = () => \"any\";\ng.JsdocTypeObject = (e, t) => `(${Qe(e, t)})`;\ng.JsdocTypeOptional = (e, t) => t(e.element);\ng.JsdocTypeNullable = (e, t) => t(e.element);\ng.JsdocTypeNotNullable = (e, t) => t(e.element);\ng.JsdocTypeUnion = (e, t) => e.elements.map(t).join(\"|\");\nfunction te(e) {\n  try {\n    return Ue(e, \"typescript\");\n  } catch {\n    return null;\n  }\n}\no(te, \"extractType\");\nfunction re(e) {\n  return Me(g, e);\n}\no(re, \"extractTypeName\");\n\n// src/docs-tools/argTypes/utils.ts\nvar ho = 90, bo = 50;\nfunction B(e) {\n  return e.length > 90;\n}\no(B, \"isTooLongForTypeSummary\");\nfunction oe(e) {\n  return e.length > 50;\n}\no(oe, \"isTooLongForDefaultValueSummary\");\nfunction l(e, t) {\n  return e === t ? { summary: e } : { summary: e, detail: t };\n}\no(l, \"createSummaryValue\");\nvar Po = /* @__PURE__ */ o((e) => e.replace(/\\\\r\\\\n/g, \"\\\\n\"), \"normalizeNewlines\");\n\n// src/docs-tools/argTypes/docgen/flow/createDefaultValue.ts\nfunction ne(e, t) {\n  if (e != null) {\n    let { value: r } = e;\n    if (!T(r))\n      return oe(r) ? l(t?.name, r) : l(r);\n  }\n  return null;\n}\no(ne, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/flow/createType.ts\nfunction se({ name: e, value: t, elements: r, raw: n }) {\n  return t ?? (r != null ? r.map(se).join(\" | \") : n ?? e);\n}\no(se, \"generateUnionElement\");\nfunction Ze({ name: e, raw: t, elements: r }) {\n  return r != null ? l(r.map(se).join(\" | \")) : t != null ? l(t.replace(/^\\|\\s*/, \"\")) : l(e);\n}\no(Ze, \"generateUnion\");\nfunction et({ type: e, raw: t }) {\n  return t != null ? l(t) : l(e);\n}\no(et, \"generateFuncSignature\");\nfunction tt({ type: e, raw: t }) {\n  return t != null ? B(t) ? l(e, t) : l(t) : l(e);\n}\no(tt, \"generateObjectSignature\");\nfunction rt(e) {\n  let { type: t } = e;\n  return t === \"object\" ? tt(e) : et(e);\n}\no(rt, \"generateSignature\");\nfunction ot({ name: e, raw: t }) {\n  return t != null ? B(t) ? l(e, t) : l(t) : l(e);\n}\no(ot, \"generateDefault\");\nfunction ie(e) {\n  if (e == null)\n    return null;\n  switch (e.name) {\n    case \"union\":\n      return Ze(e);\n    case \"signature\":\n      return rt(e);\n    default:\n      return ot(e);\n  }\n}\no(ie, \"createType\");\n\n// src/docs-tools/argTypes/docgen/flow/createPropDef.ts\nvar pe = /* @__PURE__ */ o((e, t) => {\n  let { flowType: r, description: n, required: s, defaultValue: i } = t;\n  return {\n    name: e,\n    type: ie(r),\n    required: s,\n    description: n,\n    defaultValue: ne(i ?? null, r ?? null)\n  };\n}, \"createFlowPropDef\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createDefaultValue.ts\nfunction ae({ defaultValue: e }) {\n  if (e != null) {\n    let { value: t } = e;\n    if (!T(t))\n      return l(t);\n  }\n  return null;\n}\no(ae, \"createDefaultValue\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createType.ts\nfunction ce({ tsType: e, required: t }) {\n  if (e == null)\n    return null;\n  let r = e.name;\n  return t || (r = r.replace(\" | undefined\", \"\")), l(\n    [\"Array\", \"Record\", \"signature\"].includes(e.name) ? e.raw : r\n  );\n}\no(ce, \"createType\");\n\n// src/docs-tools/argTypes/docgen/typeScript/createPropDef.ts\nvar le = /* @__PURE__ */ o((e, t) => {\n  let { description: r, required: n } = t;\n  return {\n    name: e,\n    type: ce(t),\n    required: n,\n    description: r,\n    defaultValue: ae(t)\n  };\n}, \"createTsPropDef\");\n\n// src/docs-tools/argTypes/docgen/createPropDef.ts\nfunction nt(e) {\n  return e != null ? l(e.name) : null;\n}\no(nt, \"createType\");\nfunction st(e) {\n  let { computed: t, func: r } = e;\n  return typeof t > \"u\" && typeof r > \"u\";\n}\no(st, \"isReactDocgenTypescript\");\nfunction it(e) {\n  return e ? e.name === \"string\" ? !0 : e.name === \"enum\" ? Array.isArray(e.value) && e.value.every(\n    ({ value: t }) => typeof t == \"string\" && t[0] === '\"' && t[t.length - 1] === '\"'\n  ) : !1 : !1;\n}\no(it, \"isStringValued\");\nfunction pt(e, t) {\n  if (e != null) {\n    let { value: r } = e;\n    if (!T(r))\n      return st(e) && it(t) ? l(JSON.stringify(r)) : l(r);\n  }\n  return null;\n}\no(pt, \"createDefaultValue\");\nfunction ue(e, t, r) {\n  let { description: n, required: s, defaultValue: i } = r;\n  return {\n    name: e,\n    type: nt(t),\n    required: s,\n    description: n,\n    defaultValue: pt(i, t)\n  };\n}\no(ue, \"createBasicPropDef\");\nfunction w(e, t) {\n  if (t?.includesJsDoc) {\n    let { description: r, extractedTags: n } = t;\n    r != null && (e.description = t.description);\n    let s = {\n      ...n,\n      params: n?.params?.map(\n        (i) => ({\n          name: i.getPrettyName(),\n          description: i.description\n        })\n      )\n    };\n    Object.values(s).filter(Boolean).length > 0 && (e.jsDocTags = s);\n  }\n  return e;\n}\no(w, \"applyJsDocResult\");\nvar at = /* @__PURE__ */ o((e, t, r) => {\n  let n = ue(e, t.type, t);\n  return n.sbType = b(t), w(n, r);\n}, \"javaScriptFactory\"), ct = /* @__PURE__ */ o((e, t, r) => {\n  let n = le(e, t);\n  return n.sbType = b(t), w(n, r);\n}, \"tsFactory\"), lt = /* @__PURE__ */ o((e, t, r) => {\n  let n = pe(e, t);\n  return n.sbType = b(t), w(n, r);\n}, \"flowFactory\"), ut = /* @__PURE__ */ o((e, t, r) => {\n  let n = ue(e, { name: \"unknown\" }, t);\n  return w(n, r);\n}, \"unknownFactory\"), I = /* @__PURE__ */ o((e) => {\n  switch (e) {\n    case \"JavaScript\":\n      return at;\n    case \"TypeScript\":\n      return ct;\n    case \"Flow\":\n      return lt;\n    default:\n      return ut;\n  }\n}, \"getPropDefFactory\");\n\n// src/docs-tools/argTypes/docgen/extractDocgenProps.ts\nvar me = /* @__PURE__ */ o((e) => e.type != null ? \"JavaScript\" : e.flowType != null ? \"Flow\" : e.tsType != null ? \"TypeScript\" : \"Unknown\",\n\"getTypeSystem\"), mt = /* @__PURE__ */ o((e) => {\n  let t = me(e[0]), r = I(t);\n  return e.map((n) => {\n    let s = n;\n    return n.type?.elements && (s = {\n      ...n,\n      type: {\n        ...n.type,\n        value: n.type.elements\n      }\n    }), fe(s.name, s, t, r);\n  });\n}, \"extractComponentSectionArray\"), ft = /* @__PURE__ */ o((e) => {\n  let t = Object.keys(e), r = me(e[t[0]]), n = I(r);\n  return t.map((s) => {\n    let i = e[s];\n    return i != null ? fe(s, i, r, n) : null;\n  }).filter(Boolean);\n}, \"extractComponentSectionObject\"), on = /* @__PURE__ */ o((e, t) => {\n  let r = Y(e, t);\n  return $(r) ? Array.isArray(r) ? mt(r) : ft(r) : [];\n}, \"extractComponentProps\");\nfunction fe(e, t, r, n) {\n  let s = Q(t.description);\n  return s.includesJsDoc && s.ignore ? null : {\n    propDef: n(e, t, s),\n    jsDocTags: s.extractedTags,\n    docgenInfo: t,\n    typeSystem: r\n  };\n}\no(fe, \"extractProp\");\nfunction nn(e) {\n  return e != null ? q(e) : \"\";\n}\no(nn, \"extractComponentDescription\");\n\n// src/docs-tools/argTypes/enhanceArgTypes.ts\nimport { combineParameters as yt } from \"@storybook/core/preview-api\";\nvar cn = /* @__PURE__ */ o((e) => {\n  let {\n    component: t,\n    argTypes: r,\n    parameters: { docs: n = {} }\n  } = e, { extractArgTypes: s } = n, i = s && t ? s(t) : {};\n  return i ? yt(i, r) : r;\n}, \"enhanceArgTypes\");\n\n// src/docs-tools/shared.ts\nvar ye = \"storybook/docs\", mn = `${ye}/panel`, fn = \"docs\", yn = `${ye}/snippet-rendered`, gt = /* @__PURE__ */ ((n) => (n.AUTO = \"auto\", n.\nCODE = \"code\", n.DYNAMIC = \"dynamic\", n))(gt || {});\n\n// src/docs-tools/hasDocsOrControls.ts\nvar dt = /(addons\\/|addon-|addon-essentials\\/)(docs|controls)/, dn = /* @__PURE__ */ o((e) => e.presetsList?.some((t) => dt.test(t.name)), \"\\\nhasDocsOrControls\");\nexport {\n  ye as ADDON_ID,\n  bo as MAX_DEFAULT_VALUE_SUMMARY_LENGTH,\n  ho as MAX_TYPE_SUMMARY_LENGTH,\n  mn as PANEL_ID,\n  fn as PARAM_KEY,\n  yn as SNIPPET_RENDERED,\n  gt as SourceType,\n  je as TypeSystem,\n  b as convert,\n  l as createSummaryValue,\n  cn as enhanceArgTypes,\n  nn as extractComponentDescription,\n  on as extractComponentProps,\n  mt as extractComponentSectionArray,\n  ft as extractComponentSectionObject,\n  q as getDocgenDescription,\n  Y as getDocgenSection,\n  z as hasDocgen,\n  dn as hasDocsOrControls,\n  T as isDefaultValueBlacklisted,\n  oe as isTooLongForDefaultValueSummary,\n  B as isTooLongForTypeSummary,\n  $ as isValidDocgenSection,\n  Po as normalizeNewlines,\n  Q as parseJsDoc,\n  M as str\n};\n"],"names":["global","factory","exports","this","tokenToString","token","NoParsletFoundError","EarlyEndOfParseError","UnexpectedTypeError","result","message","error","makePunctuationRule","type","text","getQuoted","position","char","mark","escaped","identifierStartRegex","identifierContinueRegex","getIdentifier","numberRegex","getNumber","_a","_b","identifierRule","value","makeKeyWordRule","prepends","stringValueRule","eofRule","numberRule","rules","breakingWhitespaceRegex","Lexer","current","next","previous","startOfLine","rule","partial","assertRootResult","assertPlainKeyValueOrRootResult","assertPlainKeyValueResult","assertPlainKeyValueOrNameResult","assertNumberOrVariadicNameResult","isSquaredProperty","Precedence","Parser","grammar","textOrLexer","baseParser","precedence","left","parslet","types","parser","isQuestionMarkUnknownType","nullableParslet","composeParslet","options","curPrecedence","optionalParslet","numberParslet","parenthesisParslet","specialTypesParslet","notNullableParslet","createParameterListParslet","allowTrailingComma","elements","e","genericParslet","dot","objects","unionParslet","baseGrammar","createNamePathParslet","allowSquareBracketsOnAnyType","allowJsdocNamePaths","pathGrammar","pathType","brackets","pathParser","parsed","right","createNameParslet","allowedAdditionalTokens","stringValueParslet","createSpecialNamePathParslet","allowedTypes","allowed","moduleParser","moduleResult","basePathGrammar","getParameters","parameters","p","getUnnamedParameters","createFunctionParslet","allowNamedParameters","allowNoReturnType","allowWithoutParenthesis","allowNewAsFunctionKeyword","newKeyword","hasParenthesis","createVariadicParslet","allowPostfix","allowEnclosingBrackets","element","symbolParslet","arrayBracketsParslet","createObjectParslet","objectFieldGrammar","allowKeyTypes","separator","fieldParser","field","optional","quote","createObjectFieldParslet","allowSquaredProperties","allowReadonly","allowOptional","readonlyProperty","parentParser","createKeyValueParslet","allowVariadic","variadic","jsdocBaseGrammar","jsdocGrammar","typeOfParslet","objectFieldGrammar$1","closureGrammar","assertsParslet","createTupleParslet","allowQuestionMark","typeList","keyOfParslet","importParslet","path","readonlyPropertyParslet","arrowFunctionParslet","intersectionParslet","predicateParslet","objectSquaredPropertyParslet","key","typescriptGrammar","parse","expression","mode","tryParse","modes","transform","parseResult","aParseResult","notAvailableTransform","extractSpecialParams","source","param","applyPosition","target","stringifyRules","stringified","transformed","storedStringifyRules","stringify","reservedWords","makeName","catharsisTransformRules","params","o","leftResult","rightValue","joiner","trailingDots","catharsisTransform","getQuoteStyle","getMemberType","nestResults","results","jtpRules","specialParams","entries","hasEventPrefix","name","quoteStyle","tModule","jtpTransform","identityTransformRules","visitorKeys","_traverse","node","parentNode","property","onEnter","onLeave","keysToVisit","traverse","De","t","Te","j","r","n","s","i","we","ke","T","M","z","$","Y","q","f","k","G","y","K","X","F","Fe","J","Je","a","N","c","u","R","P","S","Re","m","Ne","Ae","O","v","A","Ve","Be","Ce","_e","V","ge","E","L","U","de","xe","Ie","C","H","ze","$e","Ye","Q","qe","Ke","Xe","He","Ge","te","ee","re","Z","g","We","Qe","Ue","Me","B","oe","l","ne","se","Ze","et","tt","rt","ot","ie","ae","ce","nt","st","it","pt","ue","w","fe","nn","yt","cn","ye","yn","gt"],"mappings":"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","x_google_ignoreList":[0,1]}